{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction "},"linux/":{"url":"linux/","title":"Linux","keywords":"","body":"Linux Note "},"linux/supervisor.html":{"url":"linux/supervisor.html","title":"supervisor","keywords":"","body":"简介 Supervisor 是可以在类 UNIX 系统中进行管理和监控各种进程的小型系统。它自带了客户端和服务端工具。可以通过用户所定义的配置文件来管理和监控单个或多个进程，并且它可以根据配置来对异常崩溃的进程进行重启操作。 环境信息 [root@suhw ~]# cat /etc/redhat-release CentOS Linux release 7.7.1908 (Core) 安装 [root@suhw ~]# yum install epel-release [root@suhw ~]# yum install -y supervisor [root@suhw ~]# systemctl enable supervisord # 开机自启动 [root@suhw ~]# systemctl start supervisord # 启动supervisord服务 [root@suhw ~]# systemctl status supervisord # 查看supervisord服务状态 配置 配置选项可具体参考/etc/supervisord.conf中的详细介绍，或者可参考http://supervisord.org/ 若想新增要管理的进程，直接在supervisor的配置文件默认目录/etc/supervisord.d/下添加ini文件即可，在/etc/supervisord.conf中已定义会将/etc/supervisord.d/目录下所有的ini文件都会包含进来。 ... [include] files = supervisord.d/*.ini 管理redis 每个 program 代表了一个要进行管理的进程，我们可以在这里进行进程的相关配置。 编辑配置文件 假设此时需要使用supervisor管理redis-server，编辑/etc/supervisord.d/redis.ini # 项目名 [program:redis] # 脚本执行命令 command=/usr/bin/redis-server /etc/redis.conf # 当进程数为 1 时 为 %(program_name)s # 当进程数 >1 时 应配置为 %(program_name)s_%(process_num)02d process_name=%(program_name)s # 如果numprocs>1，supervisor启动当前program时会实例化好几个子进程，默认情况取1 numprocs=1 # supervisord作为守护进程的时候，会转换路径到该目录 directory=/suhw/data/redis # supervisord进程的文件权限掩码，默认 022 umask=022 # 进程启动优先级，默认999，值小的优先启动 priority=999 # supervisor启动时是否跟随同时启动(默认为true) autostart=true # 启动1秒后没有异常退出，就表示进程正常启动了，默认为1秒 startsecs=2 # 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启 autorestart=true # 启动失败自动重试次数，默认是3 startretries=100 # 脚本运行的用户身份 # user=csmp # 把stderr重定向到stdout，默认 false redirect_stderr=true # 日志输出 stdout_logfile=/suhw/data/redis/logs/%(program_name)s-stdout.log # stdout日志文件大小，默认 50MB stdout_logfile_maxbytes=10MB # stdout 日志文件备份数 stdout_logfile_backups=10 # 当进程处于stdout capture mode模式的时候，写入capture FIFO的最大字节数限制，默认为0，此时认为stdout capture mode模式关闭； stdout_capture_maxbytes=10MB 重新载入配置 # 重新加载配置并根据需要添加/删除，并将重新启动受影响的程序 [root@suhw ~]# supervisorctl update # 重新载入 supervisord [root@suhw ~]# supervisorctl reload 查看状态 [root@suhw ~]# supervisorctl status redis RUNNING pid 19573, uptime 0:00:18 此时redis服务已经被supervisor所接管了，我们以后就可通过supervisorctl进行服务的操作 supervisorctl操作 supervisorctl 是 supervisord 的命令行客户端工具，直接输入supervisorctl可进入交互界面，也可直接输入shell命令操作。 [root@suhw ~]# supervisorctl redis RUNNING pid 19573, uptime 0:20:06 supervisor> help default commands (type help ): ===================================== add exit open reload restart start tail avail fg pid remove shutdown status update clear maintail quit reread signal stop version supervisorctl可选参数如上，可以在交互模式中输入 help xxx查看对应命令的作用，举例如下 supervisor> help reload reload Restart the remote supervisord. "},"linux/vsftpd.html":{"url":"linux/vsftpd.html","title":"vsftpd","keywords":"","body":"FTP 介绍 FTP(File transfer protocol)在TCP/IP协议族中属于应用层协议运行于TCP协议之上是一种可靠的传输协议，主要功能用于实现用户间文件分发共享，以及网络管理者在进行设备版本升级、日志下载和配置保存等业务操作时，均会使用到FTP功能。 FTP不同于其他服务的是它使用了两个端口，一个数据端口（通常为20端口），一个命令端口，也称控制端口（通常为21端口） 传输模式 FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动模式和被动模式。其中是否主动是站在FTP服务端来讨论的，而选择使用哪种传输方式的选择权则是在FTP客户端。 主动模式 主动模式下，FTP客户端从任意的非特殊端口（N>1023）连入到FTP服务器的21命令端口，然后客户端在（N+1）端口监听，并且通过N+1端口发送PORT命令将N+1端口告知服务器，然后服务器会主动从自己的20数据端口发起到客户端告知的N+1端口的连接。连接成功后，开始传输数据。 被动模式 被动模式对应命令为 PASV（全称Passive）。在被动模式中，命令连接和数据连接都由客户端发起。当开启FTP连接时，客户端打开任意两个非特权端口（N>1023和N+1）。第一个端口连接服务器的21端口，并发送PASV命令告知服务器启动被动模式，服务端接收到PASV命令后，开启一个任意非特权端口（P>1024），并发送PORT P命令给客户端，然后由客户端主动从本地N+1到服务器的P端口的连接 区别 简单说 主动模式就是服务器 主动连接 到客户端的端口，而被动模式就是客户端主动连接服务器的端口，服务器负责开放端口后进行监听，等待客户端连接。 使用场景 当client端和server端同处一个局域网使用两种模式都不会存在问题， 但现实环境中无论是Client端还是Server端都是在防火墙后面，在主动模式下VSFTP会链接Client端的随机+1号端口，Client端显然不会将防火墙上所有随机端口开放；而在被动下问题同样的问题仍然会摆在Server端的防火墙面前，这就需要Server端的防火墙开启连接追踪功能，即放行与21号端口有关联的端口访问请求，这也就是为什么大部分情况下VSFTP是以被动模式工作。 Vsftpd 介绍 vsftpd(Very Secure FTP Daemon)，是一个以安全为主的FTP服务器 安装 [root@suhw ~]# yum install -y vsftpd 启动 # 启动 vsftpd [root@suhw ~]# systemctl start vsftpd # 查看状态 [root@suhw ~]# systemctl status vsftpd ● vsftpd.service - Vsftpd ftp daemon Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; disabled; vendor preset: disabled) Active: active (running) since Wed 2020-06-17 20:12:50 CST; 6s ago Process: 17277 ExecStart=/usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf (code=exited, status=0/SUCCESS) Main PID: 17278 (vsftpd) Tasks: 1 Memory: 648.0K CGroup: /system.slice/vsftpd.service └─17278 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf Jun 17 20:12:47 suhw systemd[1]: Starting Vsftpd ftp daemon... Jun 17 20:12:50 suhw systemd[1]: Started Vsftpd ftp daemon. 配置文件 文件地址 作用 /etc/vsftpd/vsftpd.conf vsftpd 配置文件 /etc/pam.d/vsftpd vsftpd 使用 pam 时的相关破欸之 /etc/vsftpd/ftpusers 记录着 拒绝登录ftp 的账号 /etc/vsftpd/user_list 记录需要管理的 vsftpd 用户账号 ，与 vsftpd.conf 中的 userlist_anle，userlist_deny 有关，控制列表中的用户是否可登录 vsftpd 账号 /etc/vsftpd/chroot_list 将指定用户 chroot 在对应的家目录下，与vsftpd.conf 中的 chroot_list_enable 和 chroot_list_file 有关 /var/ftp vsftpd 预设匿名者登录的根目录 参数介绍 下面只列举/etc/vsftpd/vsftpd.conf中部分参数介绍，详细介绍参考man 5 vsftpd.conf 参数 作用 anonymous_enable=NO 是否允许匿名帐户登录 FTP 服务器 local_enable=YES 是否允许本地账户登录 FTP 服务器 write_enable =YES 是否开启目录上次权限 local_umask=022 本地用户上传文件的权限掩码 目录消息 dirmessage_enable=YES 用户第一次进入目录时，vsftpd会查看.message文件，并将其内容显示给用户 message_file 指定文件路径，而非默认的.message 数据传输日志 xferlog_enable=YES 是否开启日志功能 xferlog_file=/var/log/vsftpd.log 日志的存放路径 xferlog_std_format=No 日志的格式 数据传输模式 connect_from_port_20=YES 是否启用PORT模式 chroot_local_user=YES 修改匿名用户上传的文件的属主 chown_uploads 是否修改 chown_username 启用chown_uploads指令时，将文件属主修改为此指令指定的用户，默认为root chown_upload_mode 设置匿名用户上传文件的权限，默认600 设定会话超时时长 idle_session_timeout 空闲会话超时时长 connect_timeout prot模式下，服务器连接客户端的超时时长 data_connection_timeout 数据传输的超时时长 与主机相关的设定值 listen_port 默认为21 listen 若设定为YES 表示 vsftpd 以standalone 方式启动，默认为No 设定连接及传输速率 local_max_rate 本地用户的最大传输速率 anon_max_rate 匿名用户的最大传输速率 max_clients 最大并发连接数 max_per_ip 每个ip所允许发起的最大连接数 禁锢本地用户 chroot_local_user 是否禁锢所有本地用户 chroot_list_enable 用户访问控制 userlist_enable 若置为开启，vsftpd将加载由userlist_file指令指定的用户列表文件，此文件中的用户是否能访问vsftpd服务取决于userlist_deny指令； userlist_deny 表示此列表是否为黑名单(YES表示为黑名单，反之为白名单) pasv_enable 值为 YES 表示启动被动模式 pasv_min_port=0 pasv_max_port=0 设定被动模式所用的端口号，0代表随机取用 pasv_address 设置ftp服务器返回的pasv地址 被动模式配置 上面介绍了两种传输模式的区别以及各自应用场景，实际开发过程中被动模式十分常见，相关的配置可参考如下： # 启用被动模式 pasv_enable=YES # 随机端口所用的端口号范围 pasv_min_port=6000 pasv_max_port=7000 #指定被动模式回传的服务器IP地址 pasv_address=10.44.192.126 # 指定vsftpd侦听的地址为非IPv6格式 listen_ipv6=NO # 以 standalone 方式启动 listen=YES 参考 http://linux.vbird.org/linux_server/0410vsftpd.php https://yq.aliyun.com/articles/545714 http://blog.sina.com.cn/s/blog_946cb2b70100x4zc.html "},"linux/LDAP统一认证服务.html":{"url":"linux/LDAP统一认证服务.html","title":"LDAP统一认证服务","keywords":"","body":"目的 通过以下步骤最终可使用ldap server中的用户登录一台ldap client，并允许有sudo权限。平常公司中所用的域账号以及服务器账号也许就是使用如下方式，但是应该没有这么简陋，只是借机了解一波ldap 环境信息 [root@suhw ~]# hostnamectl Static hostname: suhw Icon name: computer-vm Chassis: vm Machine ID: c9006a74a3674913a1e2bf3f582ec2a3 Boot ID: 1421443538404e6aa9c26cebe889446c Virtualization: kvm Operating System: CentOS Linux 7 (Core) CPE OS Name: cpe:/o:centos:centos:7 Kernel: Linux 3.10.0-957.el7.x86_64 Architecture: x86-64 名词解释 LDAP(Light Directory Access Portocol)轻量级目录访问协议。现在许多产品都加入了对LDAP的支持，可以通过简单的配置与服务器做认证服务。用户只需要使用一个密码登录众多个支持LDAP协议的应用，由应用自己去LDAP Server去认证用户信息，不仅做到了用户信息的统一管理，对于应用认证也十分方便。接下来了解一些基本概念 目录树概念 目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是一个条目。 条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称（DN）。 对象类：与某个实体类型对应的一组属性，对象类是可以继承的，这样父类的必须属性也会被继承下来。 属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。 关键字解释 关键字 英文全称 含义 dc Domain Component 域名的部分，其格式是将完整的域名分成几部分，如域名为example.com变成dc=example,dc=com（一条记录的所属位置） ou Organization Unit 组织单位，组织单位可以包含其他各种对象（包括其他组织单元），如“oa组”（一条记录的所属组织） cn Common Name 公共名称，如“Thomas Johansson”（一条记录的名称） dn Distinguished Name “uid=songtao.xu,ou=oa组,dc=example,dc=com”，一条记录的位置（唯一） 服务端安装 [root@suhw ~]# yum -y install openldap-servers openldap-clients 启动 生成密钥 记住输出结果，后续会将加密后的结果设置为初始用户的密码 [root@suhw ~]# slappasswd -s 123456 {SSHA}naG35hsGaMHojVoOoZQvjinkza4XUSBr 修改所属用户与组 [root@suhw ~]# chown ldap:ldap /var/lib/ldap/* 启动 LDAP 服务 [root@suhw ~]# systemctl start slapd [root@suhw ~]# systemctl enable slapd 配置 添加基础模块 [root@suhw ~]# ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/cosine.ldif [root@suhw ~]# ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/nis.ldif [root@suhw ~]# ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/inetorgperson.ldif 导入生效 [root@suhw ~]# ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/cosine.ldif SASL/EXTERNAL authentication started SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth SASL SSF: 0 adding new entry \"cn=cosine,cn=schema,cn=config\" [root@suhw ~]# ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/nis.ldif SASL/EXTERNAL authentication started SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth SASL SSF: 0 adding new entry \"cn=nis,cn=schema,cn=config\" [root@suhw ~]# ldapadd -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/inetorgperson.ldif SASL/EXTERNAL authentication started SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth SASL SSF: 0 adding new entry \"cn=inetorgperson,cn=schema,cn=config\" 配置域信息 创建/etc/openldap/schema/changes.ldif文件，将要替换的部分更改为自己的数据。 # 修改域名 dn: olcDatabase={2}hdb,cn=config changetype: modify replace: olcSuffix # 注意修改 olcSuffix: dc=suhw,dc=com # 修改管理员用户 dn: olcDatabase={2}hdb,cn=config changetype: modify replace: olcRootDN # 注意修改 olcRootDN: cn=admin,dc=suhw,dc=com # 修改管理员密码 dn: olcDatabase={2}hdb,cn=config changetype: modify replace: olcRootPW # 替换为 slappasswd 生成后的结果 olcRootPW: {SSHA}naG35hsGaMHojVoOoZQvjinkza4XUSBr # 修改访问权限 dn: olcDatabase={1}monitor,cn=config changetype: modify replace: olcAccess olcAccess: {0}to * by dn.base=\"gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth\" read by #修改dn.base dn.base=\"cn=admin,dc=suhw,dc=com\" read by * none 导入配置 [root@suhw ~]# ldapmodify -Y EXTERNAL -H ldapi:/// -f /etc/openldap/schema/changes.ldif SASL/EXTERNAL authentication started SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth SASL SSF: 0 modifying entry \"olcDatabase={2}hdb,cn=config\" modifying entry \"olcDatabase={2}hdb,cn=config\" modifying entry \"olcDatabase={2}hdb,cn=config\" modifying entry \"olcDatabase={1}monitor,cn=config\" 创建域和组织 [root@suhw ~]# vi /etc/openldap/schema/basedomain.ldif dn,dc的地方修改为自己对应的内容 dn: dc=suhw,dc=com dc: suhw objectClass: top objectClass: domain dn: ou=People,dc=suhw,dc=com ou: People objectClass: top objectClass: organizationalUnit dn: ou=Group,dc=suhw,dc=com ou: Group objectClass: top objectClass: organizationalUnit 导入配置，回车后输入之前创建用户未加密之前的密码 [root@suhw ~]# ldapadd -x -D cn=admin,dc=suhw,dc=com -W -f /etc/openldap/base.ldif Enter LDAP Password: adding new entry \"dc=suhw,dc=com\" adding new entry \"ou=People,dc=suhw,dc=com\" adding new entry \"ou=Group,dc=suhw,dc=com\" 查看用户列表 [root@suhw ~]# ldapsearch -x -b \"ou=People,dc=suhw,dc=com\" | grep dn 安装图形化界面 了解到的两种图像化界面，一种是LDAP Admin，另外一种是PHPLDAPAdmin。通过这两个工具，可以方便的进行用户的增删查改等操作。 PHPLDAPAdmin安装 直接采用docker安装方便。首先记得放开ldapserver的389端口或关闭防火墙，否则登录会出错 [root@suhw openldap]# firewall-cmd --zone=public --add-port=389/tcp --permanent success [root@suhw openldap]# systemctl restart firewalld 执行docker安装命令 docker run -d --privileged -p 10004:80 --name myphpldapadmin \\ --env PHPLDAPADMIN_HTTPS=false --env PHPLDAPADMIN_LDAP_HOSTS=10.91.156.198 \\ --detach osixia/phpldapadmin 配置的Ldap地址：--env PHPLDAPADMIN_LDAP_HOSTS=10.91.156.198 配置不开启HTTPS：--env PHPLDAPADMIN_HTTPS=false（默认是true） 容器运行以后访问http://host:10004即可。 LDAP Admin安装 Ldap Admin是一个用于LDAP目录管理的免费Windows LDAP客户端和管理工具。此应用程序允许您在LDAP服务器上浏览，搜索，修改，创建和删除对象。它还支持更复杂的操作，例如目录复制和在远程服务器之间移动，并扩展常用编辑功能以支持特定对象类型（例如组和帐户）。 下载地址：http://www.ldapadmin.org/ 安装成功后登录界面如下： 客户端配置 安装 在任意一台机器上首先安装nss-pam-ldapd [root@node ~]# yum install openldap-client nss-pam-ldapd -y 使用authconfig进行ldap认证的相关设置 [root@node ~]# authconfig --enableldap --enableldapauth --enablemkhomedir --enableforcelegacy --disablesssd --disablesssdauth --disableldaptls --enablelocauthorize --ldapserver=10.91.156.205 --ldapbasedn=\"dc=suhw,dc=com\" --enableshadow --update --ldapserver填写对应ldapserver的地址，basedn填写基础的域信息。 假设我在10.91.156.209上进行完成上述操作，那以后就可以通过test01@10.91.156.209进行登录，209机器会拿用户信息去找ldapserver进行验证。 添加用户 新建sudoers组织 新建 cloud 组 查看 group 属性 在LDAP server上添加id为7958的group与之对应 [root@server ~]# groupadd -g 7958 cloud [root@server ~]# tail /etc/group -n 1 cloud:x:7958: 新建test用户并放置在cloud组下 设置user相关属性 右键用户设置密码123456 保存后将test01用户挪至cloud组下，并修改用户gid为之前的7958 此时通过test01@10.91.156.205访问ldap client，即可访问成功，并会在ldap client中新建/home/test01作为家目录 注：添加用户和组时id注意别和ldapserver中的重复。 配置sudo 要向给test01用户sudo权限，可以直接通过visudo编辑/etc/sudoers配置文件，将cloud组加置对应位置即可 106 ## Allows people in group wheel to run all commands 107 %wheel ALL=(ALL) ALL 108 %cloud ALL=(ALL) ALL 此时再去重新连接就可拥有sudo权限。更详细的权限控制自行搜索 参考 https://www.cnblogs.com/wilburxu/p/9174353.html https://blog.mylitboy.com/article/operation/docker-install-openldap.html https://www.cnblogs.com/xiaomifeng0510/p/9564688.html https://cloud.tencent.com/developer/article/1563031 https://www.runoob.com/linux/linux-user-manage.html "},"linux/磁盘操作命令小结.html":{"url":"linux/磁盘操作命令小结.html","title":"磁盘操作命令小结","keywords":"","body":"以下几个命令在操作磁盘时容易搞混，特此梳理一下各自的使用场景 df 作用 df - report file system disk space usage 用于展示文件系统的磁盘使用情况 示例 [root@suhw ~]# df -hT Filesystem Type Size Used Avail Use% Mounted on /dev/mapper/centos-root xfs 17G 1013M 16G 6% / devtmpfs devtmpfs 3.9G 0 3.9G 0% /dev tmpfs tmpfs 3.9G 0 3.9G 0% /dev/shm tmpfs tmpfs 3.9G 41M 3.8G 2% /run tmpfs tmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup /dev/sda1 xfs 1014M 145M 870M 15% /boot tmpfs tmpfs 783M 0 783M 0% /run/user/0 常用参数 -h, --human-readable 用易读的方式打印大小 (e.g., 1K 234M 2G) -T, --print-type 打印文件系统类型 du 作用 du - estimate file space usage 用于估计文件空间使用情况 示例 [root@suhw ~]# du -h file.txt 4.0K file.txt 常用参数 -h, --human-readable 用易读的方式打印大小 (e.g., 1K 234M 2G) fdisk 作用 fdisk - manipulate disk partition table 操作磁盘分区表 示例 打印磁盘分区信息 [root@suhw ~]# fdisk -l Disk /dev/sda: 85.9 GB, 85899345920 bytes, 167772160 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000d8731 Device Boot Start End Blocks Id System /dev/sda1 * 2048 2099199 1048576 83 Linux /dev/sda2 2099200 41943039 19921920 8e Linux LVM Disk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes 对设备进行交互式操作 [root@suhw ~]# fdisk /dev/sda Welcome to fdisk (util-linux 2.23.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table Building a new DOS disklabel with disk identifier 0x9009d40d. Command (m for help): m Command action a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition g create a new empty GPT partition table G create an IRIX (SGI) partition table l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition's system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only) 根据提示信息对磁盘分区进行后续的操作 lsblk 作用 lsblk - list block devices 列出所有可用块设备信息，同时显示他们之间的依赖关系。 示例 [root@suhw ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 80G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 19G 0 part ├─centos-root 253:0 0 17G 0 lvm / └─centos-swap 253:1 0 2G 0 lvm [SWAP] 字段解释 字段 解释 NAME 块设备名 MAJ:MIN 主要和次要设备号 RM 是否是可移动设备 SIZE 设备的容量大小信息 RO 是否为只读 TYPE 显示块设备类型 disk磁盘，part分区，lvm逻辑卷，room只读存储 MOUNTPOINT 设置挂载的挂载点 常用参数 [root@study ~]# lsblk [-dfimpt] [device] 选项与参数： -d ：仅列出磁盘本身，并不会列出该磁盘的分区数据 -f ：同时列出该磁盘内的文件系统名称 -i ：使用 ASCII 的线段输出，不要使用复杂的编码 （再某些环境下很有用） -m ：同时输出该设备在 /dev 下面的权限数据 （rwx 的数据） -p ：列出该设备的完整文件名！而不是仅列出最后的名字而已。 -t ：列出该磁盘设备的详细数据，包括磁盘伫列机制、预读写的数据量大小等 blkid 作用 blkid - locate/print block device attributes 打印块设备属性 示例 查看设备的uuid以及type等信息 [root@suhw ~]# blkid /dev/mapper/centos-root: UUID=\"a6273829-ea65-4d66-8975-e57bda2c45a3\" TYPE=\"xfs\" /dev/sda2: UUID=\"eJxxnr-dqUB-oZlr-j6Hr-MUWl-oJs6-JUBALe\" TYPE=\"LVM2_member\" /dev/sda1: UUID=\"20c37421-fe58-4a0e-98ef-10acf395ffbf\" TYPE=\"xfs\" /dev/mapper/centos-swap: UUID=\"5bc2d0fa-6abd-4e60-a7ea-743ef62dff65\" TYPE=\"swap\" parted 作用 parted - a partition manipulation program 用于操作分区的程序 示例 通过parted查看分区信息，可看除分区格式是msdos（MBR） [root@suhw ~]# parted /dev/sda print Model: QEMU QEMU HARDDISK (scsi) Disk /dev/sda: 85.9GB Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 1 1049kB 1075MB 1074MB primary xfs boot 2 1075MB 21.5GB 20.4GB primary lvm 3 21.5GB 23.6GB 2147MB primary lvm "},"linux/LVM逻辑卷的创建与扩容.html":{"url":"linux/LVM逻辑卷的创建与扩容.html","title":"LVM逻辑卷的创建与扩容","keywords":"","body":"LVM介绍 LVM简介 全称逻辑卷管理器(Logic Volume Manager)。是在内核中块设备和物理设备之间添加的一个新的抽象层次。通过LVM，可以将几块磁盘（物理卷PV）组合形成一个存储池或卷组(VG)，最终在卷组的基础上再划分逻辑卷。 LVM管理着所有物理卷的物理盘区，维持着逻辑盘区和物理盘区之间的映射。LVM逻辑设备向上层应用提供了和物理磁盘相同的功能，如文件系统的创建和数据的访问等。但LVM逻辑设备不受物理约束的限制，逻辑卷不必是连续的空间，它可以跨越许多物理卷，并且可以在任何时候任意的调整大小。相比物理磁盘来说，更易于磁盘空间的管理。可以通过下图帮助理解。 LVM优缺点 优点 在系统运行的状态下动态的扩展/减少文件系统的大小 文件系统可跨多个磁盘，不受物理磁盘的限制 当需要导出整个卷组到另外一台机器更加方便快捷 可通过磁盘镜像的方式同步备份重要的数据到其他物理磁盘 缺点 当卷组中的一个磁盘损坏时，整个卷组都会收到影响 当从卷组中移除一个磁盘时必须使用vgreduce命令 基础概念 物理存储介质 指的是系统的存储设置，如/dev/sda等，是存储系统最低层的存储单元 物理卷 简称PV(Physical Volume)。物理卷是指硬盘分区或逻辑上与磁盘分区具有同样同能的设备，是LVM的基本存储逻辑块，但和基本的物理存储介绍比较，却包含有与LVM相关的管理参数 卷组 简称VG(Volume Group)。LVM卷组类似于非LVM系统中的物理硬盘，可以在卷组上创建一个或多个LVM分区(逻辑卷)。LVM卷组由一个或多个物理卷组成，可以通过增加卷组中的物理卷实现扩容 逻辑卷 简称 LV(Logical Volume)。LVM逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上可以建立文件系统 物理块 简称PE(Physical Extent)。每一个物理卷被划分为称为PE的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元，PE的大小是可配置的，默认为4MB 逻辑块 简称lE(Logical Extent)。逻辑卷被划分为的最小可寻址的基本单位称为LE。在同一个卷组中，LE的大小和PE是相同的， 并且一一对应。 命令汇总 功能 物理卷管理PV 卷组管理VG 逻辑卷管理LV 扫描 (Scan) pvscan vgscan lvscan 建立 (Create) pvcreate vgcreate lvcreate 显示 (Display) pvdisplay vgdisplay lvdisplay 删除 (Remove) pvremove vgremove lvremove 扩展 (Extend) - vgextend lvextend 减少 (Reduce) - vgreduce lvreduce LVM的创建与挂载 按照如下步骤操作即可，若有命令不清楚自行Google 查看分区 [root@suhw ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 80G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 19G 0 part ├─centos-root 253:0 0 17G 0 lvm / └─centos-swap 253:1 0 2G 0 lvm [SWAP] 通过lsblk发现我们目前有两个分区sda1和sda2，其中sda1挂载到了/boot目录，而sda2分区下则拥有两个逻辑卷，接下来我们新增一个分区开始操作 新建分区 [root@suhw ~]# fdisk /dev/sda Welcome to fdisk (util-linux 2.23.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): m Command action a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition g create a new empty GPT partition table G create an IRIX (SGI) partition table l list known partition types m print this menu n add a new partition o create a new empty DOS partition table p print the partition table q quit without saving changes s create a new empty Sun disklabel t change a partition's system id u change display/entry units v verify the partition table w write table to disk and exit x extra functionality (experts only) Command (m for help): n Partition type: p primary (2 primary, 0 extended, 2 free) e extended Select (default p): p Partition number (3,4, default 3): 3 # 指定第一个分区，使用默认值 直接回车 First sector (41943040-167772159, default 41943040): Using default value 41943040 # 指定最后一个分区，使用+size{K,M,G} 的形式让fdisk 自己算 Last sector, +sectors or +size{K,M,G} (41943040-167772159, default 167772159): +4G Partition 3 of type Linux and of size 4 GiB is set 通过fdisk中的n可进行新增分区的操作，最终就新建了大小为4G的/dev/sda3分区，接下来将分区格式设置为 LVM。 设置LVM分区格式 # t 对应操作为 change a partition's system id Command (m for help): t # 分区序号，对刚新建的 sda3 进行操作 Partition number (1-3, default 3): 3 # 8e 对应的就是 Linux LVM， 可敲入 L 显示所有的system id Hex code (type L to list all codes): 8e Changed type of partition 'Linux' to 'Linux LVM' Command (m for help): p Disk /dev/sda: 85.9 GB, 85899345920 bytes, 167772160 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000d8731 Device Boot Start End Blocks Id System /dev/sda1 * 2048 2099199 1048576 83 Linux /dev/sda2 2099200 41943039 19921920 8e Linux LVM /dev/sda3 41943040 50331647 4194304 8e Linux LVM 通过p打印出的结果可看出此时我们新建的/dev/sda3分区已经设置为了Linux LVM格式 保存结果 Command (m for help): w The partition table has been altered! Calling ioctl() to re-read partition table. WARNING: Re-reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8) Syncing disks. w为保存退出，若想要放弃修改，敲入q即可 同步系统分区信息 在上述的修改完后，内核仍然使用的是旧的分区表，若想要通知内核更新分区信息，只有当重启后 或 运行 partprobe 或 kpartx 命令才可以。 [root@suhw ~]# partprobe 更新完成后，通过lsblk查看就会多出一个 4G的sda3分区 [root@suhw ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 80G 0 disk ├─sda1 8:1 0 1G 0 part /boot ├─sda2 8:2 0 19G 0 part │ ├─centos-root 253:0 0 17G 0 lvm / │ └─centos-swap 253:1 0 2G 0 lvm [SWAP] └─sda3 8:3 0 4G 0 part 此时我们的物理磁盘分区设置完毕，接下来就是和LVM相关的操作 新建物理卷PV 将刚才新建的磁盘分区创建为物理卷 [root@suhw ~]# pvcreate /dev/sda3 Physical volume \"/dev/sda3\" successfully created. # 查看物理卷信息 [root@suhw ~]# pvdisplay --- Physical volume --- PV Name /dev/sda2 VG Name centos PV Size 新建卷组VG 命令格式 vgcreate VG_new PV ... 新建名为suhwvg的卷组，并将物理卷/dev/sda3 加入到suhwvg中 [root@suhw ~]# vgcreate suhwvg /dev/sda3 Volume group \"suhwvg\" successfully created 查看结果创建成功 [root@suhw ~]# vgscan Reading volume groups from cache. Found volume group \"centos\" using metadata type lvm2 Found volume group \"suhwvg\" using metadata type lvm2 查看卷组VG的详细信息 [root@suhw ~]# vgdisplay --- Volume group --- VG Name suhwvg System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 1 VG Access read/write VG Status resizable MAX LV 0 Cur LV 0 Open LV 0 Max PV 0 Cur PV 1 Act PV 1 VG Size 至此PV和VG都已准备就绪，在VG基础上划分逻辑卷即可 新建逻辑卷 在suhwvg卷组中新增一个大小为2G的名为 suhwlv的逻辑卷 [root@suhw ~]# lvcreate -L 2G -n suhwlv suhwvg WARNING: xfs signature detected on /dev/suhwvg/suhwlv at offset 0. Wipe it? [y/n]: y Wiping xfs signature on /dev/suhwvg/suhwlv. Logical volume \"suhwlv\" created. 查看逻辑卷详情 [root@suhw ~]# lvdisplay --- Logical volume --- LV Path /dev/suhwvg/suhwlv LV Name suhwlv VG Name suhwvg LV UUID j8VX5e-fltA-MWVx-CGrU-BuDs-w4c1-96pC79 LV Write Access read/write LV Creation host, time suhw, 2020-09-30 10:58:46 +0800 LV Status available # open 0 LV Size 2.00 GiB Current LE 512 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:2 格式化逻辑卷 逻辑卷新建完成后，接下来将刚才新增的suhwlv逻辑卷格式化为xfs格式 [root@suhw ~]# mkfs.xfs /dev/suhwvg/suhwlv meta-data=/dev/suhwvg/suhwlv isize=512 agcount=4, agsize=131072 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0 data = bsize=4096 blocks=524288, imaxpct=25 = sunit=0 swidth=0 blks naming =version 2 bsize=4096 ascii-ci=0 ftype=1 log =internal log bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1 realtime =none extsz=4096 blocks=0, rtextents=0 设置永久挂载 新建一个目录 [root@suhw ~]# mkdir /home/suhw 编辑 /etc/fstab 文件，末尾新增一行 /dev/suhwvg/suhwlv /home/suhw xfs defaults 0 0 每一列分别代表的含义如下： 需要挂载的设备名 文件系统的挂载点 挂载文件系统类型 挂载所需参数，一般使用default 文件系统是否需要dump 是否需要开机进行fsck 检查（一般根分区设置为1，/boot分区设置为2， 0代表不需要） 使用mount命令进行挂载，-a参数即可根据/etc/fstab中的配置进行挂载 [root@suhw ~]# mount -a 查看挂载结果 [root@suhw ~]# df -hT Filesystem Type Size Used Avail Use% Mounted on /dev/mapper/centos-root xfs 17G 1013M 16G 6% / devtmpfs devtmpfs 3.9G 0 3.9G 0% /dev tmpfs tmpfs 3.9G 0 3.9G 0% /dev/shm tmpfs tmpfs 3.9G 41M 3.8G 2% /run tmpfs tmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup /dev/sda1 xfs 1014M 145M 870M 15% /boot tmpfs tmpfs 783M 0 783M 0% /run/user/0 /dev/mapper/suhwvg-suhwlv xfs 2.0G 33M 2.0G 2% /home/suhw 可以看出新建的逻辑卷的文件系统格式为xfs，大小为2G，并且挂载到了home/suhw。至此挂载成功，后续我们可以直接对该逻辑卷进行扩容/减少等操作。 LVM的扩容 我们使用的某个文件系统空间不足时，扩容是常有的事，接下来将之前的逻辑卷扩容到8G。 首先需要检查卷组可用空间是否够我们对逻辑卷进行扩容操作，够的话直接使用lvextend即可，不够还需增大卷组中的可用空间后再使用lvextend对逻辑卷扩容。整体流程大致如下： 获取文件系统信息 [root@suhw ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 80G 0 disk ├─sda1 8:1 0 1G 0 part /boot ├─sda2 8:2 0 19G 0 part │ ├─centos-root 253:0 0 17G 0 lvm / │ └─centos-swap 253:1 0 2G 0 lvm [SWAP] └─sda3 8:3 0 4G 0 part └─suhwvg-suhwlv 253:2 0 2G 0 lvm /home/suhw 我们要调整的逻辑卷为suhwvg-suhwlv 获取逻辑卷信息 [root@suhw ~]# lvdisplay --- Logical volume --- LV Path /dev/suhwvg/suhwlv LV Name suhwlv VG Name suhwvg LV UUID j8VX5e-fltA-MWVx-CGrU-BuDs-w4c1-96pC79 LV Write Access read/write LV Creation host, time suhw, 2020-09-30 10:58:46 +0800 LV Status available # open 1 LV Size 2.00 GiB Current LE 512 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:2 获取卷组信息 [root@suhw ~]# vgdisplay --- Volume group --- VG Name suhwvg System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 2 VG Access read/write VG Status resizable MAX LV 0 Cur LV 1 Open LV 1 Max PV 0 Cur PV 1 Act PV 1 VG Size 扩容卷组 卷组可用大小为511*4=2044M，我们需要4G 显然不够，所以再添加一个分区到该卷组中 [root@suhw ~]# fdisk /dev/sda Welcome to fdisk (util-linux 2.23.2). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Command (m for help): n Partition type: p primary (3 primary, 0 extended, 1 free) e extended Select (default e): p Selected partition 4 First sector (50331648-167772159, default 50331648): Using default value 50331648 Last sector, +sectors or +size{K,M,G} (50331648-167772159, default 167772159): +8G Partition 4 of type Linux and of size 8 GiB is set Command (m for help): w The partition table has been altered! Calling ioctl() to re-read partition table. WARNING: Re-reading the partition table failed with error 16: Device or resource busy. The kernel still uses the old table. The new table will be used at the next reboot or after you run partprobe(8) or kpartx(8) Syncing disks. [root@suhw ~]# partprobe 确认磁盘分区新建成功后，新建对应的物理卷，并加入到对应的卷组中 [root@suhw ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 80G 0 disk ├─sda1 8:1 0 1G 0 part /boot ├─sda2 8:2 0 19G 0 part │ ├─centos-root 253:0 0 17G 0 lvm / │ └─centos-swap 253:1 0 2G 0 lvm [SWAP] ├─sda3 8:3 0 4G 0 part │ └─suhwvg-suhwlv 253:2 0 2G 0 lvm /home/suhw └─sda4 8:4 0 8G 0 part [root@suhw ~]# pvcreate /dev/sda4 Physical volume \"/dev/sda4\" successfully created. [root@suhw ~]# vgextend suhwvg /dev/sda4 Volume group \"suhwvg\" successfully extended 加到 suhwvg 卷组后， 再次查看卷组详情就会发现可用空间已经增加 [root@suhw ~]# vgdisplay --- Volume group --- VG Name suhwvg System ID Format lvm2 Metadata Areas 2 Metadata Sequence No 3 VG Access read/write VG Status resizable MAX LV 0 Cur LV 1 Open LV 1 Max PV 0 Cur PV 2 Act PV 2 VG Size 11.99 GiB PE Size 4.00 MiB Total PE 3070 Alloc PE / Size 512 / 2.00 GiB Free PE / Size 2558 / 9.99 GiB VG UUID mVeVDv-UwuJ-pzMG-KEBb-95gW-YoKh-aww8uX 逻辑卷扩容 此时卷组中可用空间9.9G，够我们再扩4G，使用lvextennd操作即可。 注：-r 直接自动扩展文件系统大小 [root@suhw ~]# lvextend -L +4G /dev/suhwvg/suhwlv -r Size of logical volume suhwvg/suhwlv changed from 2.00 GiB (512 extents) to 6.00 GiB (1536 extents). Logical volume suhwvg/suhwlv successfully resized. meta-data=/dev/mapper/suhwvg-suhwlv isize=512 agcount=4, agsize=131072 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0 spinodes=0 data = bsize=4096 blocks=524288, imaxpct=25 = sunit=0 swidth=0 blks naming =version 2 bsize=4096 ascii-ci=0 ftype=1 log =internal bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1 realtime =none extsz=4096 blocks=0, rtextents=0 data blocks changed from 524288 to 1572864 查看结果 [root@suhw ~]# df -hT Filesystem Type Size Used Avail Use% Mounted on /dev/mapper/centos-root xfs 19G 1.1G 18G 6% / devtmpfs devtmpfs 4.1G 0 4.1G 0% /dev tmpfs tmpfs 4.2G 0 4.2G 0% /dev/shm tmpfs tmpfs 4.2G 43M 4.1G 2% /run tmpfs tmpfs 4.2G 0 4.2G 0% /sys/fs/cgroup /dev/sda1 xfs 1.1G 152M 912M 15% /boot tmpfs tmpfs 821M 0 821M 0% /run/user/0 /dev/mapper/suhwvg-suhwlv xfs 6.5G 35M 6.4G 1% /home/suhw 参考 https://www.yisu.com/zixun/3865.html https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/61.html "},"ansible/":{"url":"ansible/","title":"Ansible","keywords":"","body":"Ansible Note "},"ansible/安装介绍.html":{"url":"ansible/安装介绍.html","title":"安装介绍","keywords":"","body":"参考 bilibili马哥视频 运维派教程 介绍 ansible是一种自动化运维工具，基于Python开发，可实现批量系统配置、批量程序部署、批量运行命令等功能。 环境信息 # hostnamectl Static hostname: localhost.localdomain Icon name: computer-vm Chassis: vm Machine ID: 752d91f949a840fa9f2ed0b2ca54d8ad Boot ID: 81088a1ae25a46279b7746e8c9e0a091 Virtualization: vmware Operating System: CentOS Linux 7 (Core) CPE OS Name: cpe:/o:centos:centos:7 Kernel: Linux 3.10.0-957.el7.x86_64 Architecture: x86-64 安装 可直接通过yum安装 [root@localhost ~]# yum search ansible 校验 [root@localhost ~]# ansible --version ansible 2.9.15 config file = /etc/ansible/ansible.cfg configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python2.7/site-packages/ansible executable location = /usr/bin/ansible python version = 2.7.5 (default, Oct 30 2018, 23:45:53) [GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] 常用工具 名称 用途 ansible 主程序，临时命令执行工具 ansible-doc 查看配置文档，模块功能查看工具 ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台 ansible-playbook 定制自动化任务，编排剧本工具 ansible-pull 远程执行命令的工具 ansible-vault 文件加密工具 ansible-console 基于Console界面与用户交互的执行工具 ansible-doc 格式 ansible-doc [options] [module...] -l, --list #列出可用模块 -s, --snippet #显示指定模块的playbook片段 例如查看ping模块的简短文档 [root@localhost ~]# ansible-doc -s ping - name: Try to connect to host, verify a usable python and return `pong' on success ping: data: # Data to return for the `ping' return value. If this parameter is set to `crash', the module will cause an exception. ansible 格式 ansible [-m module_name] [-a args] --version #显示版本 -m module #指定模块，默认为command -v #详细过程 –vv -vvv更详细 --list-hosts #显示主机列表，可简写 --list -k, --ask-pass #提示输入ssh连接密码，默认Key验证 -C, --check #检查，并不执行 -T, --timeout=TIMEOUT #执行命令的超时时间，默认10s -u, --user=REMOTE_USER #执行远程执行的用户 -b, --become #代替旧版的sudo 切换 --become-user=USERNAME #指定sudo的runas用户，默认为root -K, --ask-become-pass #提示输入sudo时的口令 注：若执行-k，必须所有hosts中主机密码相同，否则可能会出现失败 示例 [root@localhost ~]# ssh-keygen [root@localhost ~]# ssh-copy-id 10.91.156.209 [root@localhost ~]# ssh-copy-id 10.91.156.205 # 此时公钥已被添加到209 205两台机器中的root用户下 [root@localhost ~]# ansible all -m ping 10.91.156.209 | SUCCESS => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } 10.91.156.205 | SUCCESS => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } 查看所有hosts [root@localhost ~]# ansible all --list-hosts hosts (2): 10.91.156.205 10.91.156.209 [root@localhost ~]# ansible server --list-hosts hosts (1): 10.91.156.209 [root@localhost ~]# ansible node --list-hosts hosts (1): 10.91.156.205 [root@localhost ~]# cat /etc/ansible/hosts [server] 10.91.156.209 [node] 10.91.156.205 ansible命令执行过程 加载自己的配置文件 默认/etc/ansible/ansible.cfg 加载自己对应的模块文件，如：command 通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件 给文件+x权限执行 执行并返回结果 删除临时py文件，退出 具体过程可通过-vvv参数来详细查看 [root@localhost ~]# ansible server -vvv -m ping > ansible.log # 增加执行权限记录 [root@localhost ~]# grep -n chmod ansible.log 31: SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/4f24120d2d 10.91.156.209 '/bin/sh -c '\"'\"'chmod u+x /root/.ansible/tmp/ansible-tmp-1608777830.06-12031-172335200139721/ /root/.ansible/tmp/ansible-tmp-1608777830.06-12031-172335200139721/AnsiballZ_ping.py && sleep 0'\"'\"'' #删除临时文件 [root@localhost ~]# grep -n chmod ansible.log ... 37: SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/4f24120d2d 10.91.156.209 '/bin/sh -c '\"'\"'rm -f -r /root/.ansible/tmp/ansible-tmp-1608777830.06-12031-172335200139721/ > /dev/null 2>&1 && sleep 0'\"'\"'' 查找ansible.cfg顺序 ANSIBLE_CONFIG：首先，Ansible命令会检查环境变量，及这个环境变量将指向的配置文件 ./ansible.cfg：其次，将会检查当前目录下的ansible.cfg配置文件 ~/.ansible.cfg：再次，将会检查当前用户home目录下的.ansible.cfg配置文件 /etc/ansible/ansible.cfg：最后，将会检查在用软件包管理工具安装Ansible时自动产生的配置文件 ansible-galaxy 此工具会连接 https://galaxy.ansible.com 下载相应的roles 示例 #列出所有已安装的galaxy ansible-galaxy list #安装galaxy ansible-galaxy install geerlingguy.mysql ansible-galaxy install geerlingguy.redis #删除galaxy ansible-galaxy remove geerlingguy.redis ansible-playbook 作用 此工具用于执行编写好的 playbook任务 示例 [root@localhost ~]# cat hello.yml - hosts: server remote_user: root tasks: - name: hello world command: /usr/bin/wall hello world 执行结果 ansible-vault 作用 此工具可以用于加密解密yml文件 示例 ansible-vault encrypt hello.yml #加密 ansible-vault decrypt hello.yml #解密 ansible-vault view hello.yml #查看 ansible-vault edit hello.yml #编辑加密文件 ansible-vault rekey hello.yml #修改口令 ansible-vault create new.yml #创建新文件 ansible-console 此工具可交互执行命令，支持tab，ansible 2.0+新增 提示符格式： 执行用户@当前操作的主机组 (当前组的主机数量)[f:并发数]$ 常用子命令 设置并发数： forks n 例如： forks 10 切换组： cd 主机组 例如： cd web 列出当前组主机列表： list 列出所有的内置命令： ?或help 范例 [root@ansible ~]#ansible-console Welcome to the ansible console. Type help or ? to list commands. root@all (3)[f:5]list 10.0.0.8 10.0.0.7 10.0.0.6 root@all (3)[f:5] cd websrvs root@websrvs (2)[f:5]list 10.0.0.7 10.0.0.8 root@websrvs (2)[f:5] forks 10 root@websrvs (2)[f:10]cd appsrvs root@appsrvs (2)[f:5] yum name=httpd state=present root@appsrvs (2)[f:5]$ service name=httpd state=started 其它 输出颜色代表含义 ansible执行完任务后，会根据不同的颜色来说明执行的结果，默认颜色的含义如下（在/etc/ansible/ansible.cfg中）。其中最常见的就是红黄绿三种颜色。 [colors] #highlight = white #verbose = blue #warn = bright purple # 执行失败 #error = red #debug = dark gray #deprecate = purple #skip = cyan #unreachable = red #ok = green # 执行成功并且对目标主机做变更 #changed = yellow # 执行成功并且不需要做改变的操作 #diff_add = green #diff_remove = red #diff_lines = cyan "},"ansible/常用模块.html":{"url":"ansible/常用模块.html","title":"常用模块","keywords":"","body":"参考 bilibili马哥视频 运维派教程 基础配置 [root@localhost ~]# cat /etc/ansible/hosts [server] 10.91.156.209 [node] 10.91.156.205 Command模块 功能 在远程主机执行命令，此为默认模块，可忽略-m选项 注意：此命令不支持 $VARNAME | ; & 等，用shell模块实现 文档 [root@localhost ~]# ansible-doc -s command - name: Execute commands on targets command: argv: # Passes the command as a list rather than a string. Use `argv' to avoid quoting values that would otherwise be interpreted incorrectly (for example \"user name\"). Only the string or the list form can be provided, not both. One or the other must be provided. chdir: # Change into this directory before running the command. cmd: # The command to run. creates: # A filename or (since 2.0) glob pattern. If it already exists, this step *won't* be run. free_form: # The command module takes a free form command to run. There is no actual parameter named 'free form'. removes: # A filename or (since 2.0) glob pattern. If it already exists, this step *will* be run. stdin: # Set the stdin of the command directly to the specified value. stdin_add_newline: # If set to `yes', append a newline to stdin data. strip_empty_ends: # Strip empty lines from the end of stdout/stderr in result. warn: # Enable or disable task warnings. 示例 # 切换到/etc目录下 查看centos-release [root@localhost ~]# ansible server -m command -a 'chdir=/etc cat centos-release' 10.91.156.209 | CHANGED | rc=0 >> CentOS Linux release 7.6.1810 (Core) Shell模块 功能 和command相似，用shell执行命令 注意：调用bash执行命令 类似cat /tmp/test.md | awk -F‘|’ ‘{print 1,1,1,2}’ &> /tmp/example.txt这些复杂命令，即使使用shell也可能会失败，解决办法：写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器 文档 [root@localhost ~]# ansible-doc -s shell - name: Execute shell commands on targets shell: chdir: # Change into this directory before running the command. cmd: # The command to run followed by optional arguments. creates: # A filename, when it already exists, this step will *not* be run. executable: # Change the shell used to execute the command. This expects an absolute path to the executable. free_form: # The shell module takes a free form command to run, as a string. There is no actual parameter named 'free form'. See the examples on how to use this module. removes: # A filename, when it does not exist, this step will *not* be run. stdin: # Set the stdin of the command directly to the specified value. stdin_add_newline: # Whether to append a newline to stdin data. warn: # Whether to enable task warnings. 示例 将shell模块代替command，设为默认模块。编辑/etc/ansible/ansible.cfg文件 # default module name for /usr/bin/ansible #module_name = command module_name = shell 打印主机的hostname。对比发现command模块输出有问题，shell可以正常打印 [root@localhost ~]# ansible server -m command -a 'echo $HOSTNAME' 10.91.156.209 | CHANGED | rc=0 >> $HOSTNAME [root@localhost ~]# ansible server -m shell -a 'echo $HOSTNAME' 10.91.156.209 | CHANGED | rc=0 >> node Script模块 功能 在远程主机上运行ansible服务器上的脚本 文档 [root@localhost ~]# ansible-doc -s script - name: Runs a local script on a remote node after transferring it script: chdir: # Change into this directory on the remote node before running the script. cmd: # Path to the local script to run followed by optional arguments. creates: # A filename on the remote node, when it already exists, this step will *not* be run. decrypt: # This option controls the autodecryption of source files using vault. executable: # Name or path of a executable to invoke the script with. free_form: # Path to the local script file followed by optional arguments. removes: # A filename on the remote node, when it does not exist, this step will *not* be run. 示例 [root@localhost ~]# cat test.sh #!/bin/sh echo sever HostName is `hostname` [root@localhost ~]# ansible server -m script -a 'test.sh' 10.91.156.209 | CHANGED => { \"changed\": true, \"rc\": 0, \"stderr\": \"Shared connection to 10.91.156.209 closed.\\r\\n\", \"stderr_lines\": [ \"Shared connection to 10.91.156.209 closed.\" ], \"stdout\": \"sever HostName is node\\r\\n\", \"stdout_lines\": [ \"sever HostName is node\" ] } Copy模块 功能 从ansible服务器主控端复制文件到远程主机 [root@localhost ~]# ansible-doc -s copy - name: Copy files to remote locations copy: ..... 示例 #如目标存在，默认覆盖，此处指定先备份 ansible websrvs -m copy -a “src=/root/test1.sh dest=/tmp/test2.sh owner=wang mode=600 backup=yes” #指定内容，直接生成目标文件 ansible websrvs -m copy -a \"content='test line1\\ntest line2' dest=/tmp/test.txt\" #复制/etc/下的文件，不包括/etc/目录自身 ansible websrvs -m copy -a “src=/etc/ dest=/backup” Fetch模块 功能 从远程主机提取文件至ansible的主控端，copy相反，目前不支持目录 File模块 功能 设置文件属性 常见参数 参数 含义 group 文件所属组 mode 文件权限 owner 文件拥有者 path 需要管理的文件路径（必选） recurse 递归设置（当state取值为directory） src 文件的链接地址 （只当state值为link或hard时设置） state absent：目录会递归删除，文件会被删除，符号链接会被取消链接 directory：创建目录hard 创建或修改硬链接 link 创建或修改软链接 touch：如果path指定的文件不存在，则创建 示例 [root@localhost ~]# ansible server -m file -a 'path=/root/test.txt state=touch' 10.91.156.209 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"dest\": \"/root/test.txt\", \"gid\": 0, \"group\": \"root\", \"mode\": \"0644\", \"owner\": \"root\", \"secontext\": \"unconfined_u:object_r:admin_home_t:s0\", \"size\": 0, \"state\": \"file\", \"uid\": 0 } [root@localhost ~]# ansible server -a 'ls -l' 10.91.156.209 | CHANGED | rc=0 >> ... -rw-r--r--. 1 root root 0 12月 24 16:51 test.txt unarchive模块 功能 解包解压缩 实现有两种用法： 1、将ansible主机上的压缩包传到远程主机后解压缩至特定目录，设置copy=yes 2、将远程主机上的某个压缩包解压缩到指定路径下，设置copy=no 常见参数 copy：默认为yes，当copy=yes，拷贝的文件是从ansible主机复制到远程主机上，如果设置为copy=no，会在远程主机上寻找src源文件 remote_src：和copy功能一样且互斥，yes表示在远程主机，不在ansible主机，no表示文件在ansible主机上 src：源路径，可以是ansible主机上的路径，也可以是远程主机上的路径，如果是远程主机上的路径，则需要设置copy=no dest：远程主机上的目标路径 mode：设置解压缩后的文件权限 示例 # 创建压缩包 [root@localhost ~]# tar -czvf testDir.tar.gz testDir/ testDir/ testDir/test.sh # 将压缩包拷至远程主机 /root 目录下并解压 [root@localhost ~]# ansible server -m unarchive -a 'src=./testDir.tar.gz dest=/root copy=yes' 10.91.156.209 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"dest\": \"/root\", \"extract_results\": { \"cmd\": [ \"/usr/bin/gtar\", \"--extract\", \"-C\", \"/root\", \"-z\", \"-f\", \"/root/.ansible/tmp/ansible-tmp-1608812600.88-13937-63576563579965/source\" ], \"err\": \"\", \"out\": \"\", \"rc\": 0 }, \"gid\": 0, \"group\": \"root\", \"handler\": \"TgzArchive\", \"mode\": \"0550\", \"owner\": \"root\", \"secontext\": \"system_u:object_r:admin_home_t:s0\", \"size\": 244, \"src\": \"/root/.ansible/tmp/ansible-tmp-1608812600.88-13937-63576563579965/source\", \"state\": \"directory\", \"uid\": 0 } # 查看远程主机解压结果 [root@localhost ~]# ansible server -a 'ls -l /root/testDir/' 10.91.156.209 | CHANGED | rc=0 >> 总用量 4 -rwxr-xr-x. 1 root root 47 12月 24 14:31 test.sh Archive模块 功能 打包压缩 示例 # 将目标主机 /roor/testDir 目录压缩至 /root/testDir.tar.gz 权限为 644 [root@localhost ~]# ansible server -m archive -a 'path=/root/testDir/ dest=/root/testDir.tar.gz format=gz mode=644' 10.91.156.209 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"archived\": [ \"/root/testDir/test.sh\" ], \"arcroot\": \"/root/testDir/\", \"changed\": true, \"dest\": \"/root/testDir.tar.gz\", \"expanded_exclude_paths\": [], \"expanded_paths\": [ \"/root/testDir/\" ], \"gid\": 0, \"group\": \"root\", \"missing\": [], \"mode\": \"0644\", \"owner\": \"root\", \"secontext\": \"unconfined_u:object_r:admin_home_t:s0\", \"size\": 175, \"state\": \"file\", \"uid\": 0 } [root@localhost ~]# ansible server -a 'ls -l /root' 10.91.156.209 | CHANGED | rc=0 >> ... -rw-r--r--. 1 root root 175 12月 24 21:48 testDir.tar.gz Hostname模块 功能 管理主机名 参数 参数 说明 name （必填）主机名称 use 更新策略 示例 ansible server -m hostname -a “name=suhw” Cron模块 功能 计划任务 常用参数 参数 含义 minute 分 hour 小时 day 日 month 月 weekday 作业应该在一周的哪一天运行(周日-周六为0-6) job 任务路径 disabled 是否禁用任务 user 应该修改crontab的特定用户。如果没有设置，这个参数默认使用' root'。 示例 # 脚本内容：输出当前时间至log文件 [root@localhost ~]# cat /root/date.sh #/!/bin/sh date >> /root/date.log # 先拷贝到目标主机上 [root@localhost ~]# ansible server -m copy -a \"src=./date.sh dest=/root/date.sh mode=755\" # 将脚本每分钟执行一次 [root@localhost ~]# ansible server -m cron -a \"job=/root/date.sh minute=*/1 name=GetDate\" 10.91.156.205 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"envs\": [], \"jobs\": [ \"GetDate\" ] } # 查看目标主机定时任务列表 [root@localhost ~]# ansible server -a 'crontab -l' 10.91.156.205 | CHANGED | rc=0 >> #Ansible: GetDate */1 * * * * /root/date.sh # 查看执行结果 [root@localhost ~]# ansible server -a 'cat /root/date.log' 10.91.156.205 | CHANGED | rc=0 >> Fri Dec 25 19:48:01 CST 2020 # 使用 disabled 属性取消该任务 [root@localhost ~]# ansible server -m cron -a \"job=/root/date.sh minute=*/1 name=GetDate disabled=true\" 10.91.156.205 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"envs\": [], \"jobs\": [ \"GetDate\" ] } # 再次查看发现已经注释取消 [root@localhost ~]# ansible server -a 'crontab -l' 10.91.156.205 | CHANGED | rc=0 >> #Ansible: GetDate #*/1 * * * * /root/date.sh Yum模块 功能 管理软件包，只支持RHEL，CentOS，fedora，不支持Ubuntu其它版本 常用参数 参数 含义 name 包名或带有版本的包说明符，如' name-1.0'。 state 可选：absent, installed, latest, present, removed Service模块 功能 管理服务 常见参数 参数 含义 name 包名或带有版本的包说明符，如' name-1.0'。 state 可选：started 、stopped 、 restarted 、 reloaded enabled 是否开机启动 示例 # 关闭远程主机docker服务 [root@localhost ~]# ansible server -m service -a 'name=docker state=stopped' User模块 功能 管理用户 示例 # 添加用户 [root@localhost ~]# ansible server -m user -a 'name=test01 uid=8888 home=/home/test01 group=root' ... [root@localhost ~]# ansible server -a 'getent passwd test01' 10.91.156.205 | CHANGED | rc=0 >> test01:x:8888:0::/home/test01:/bin/bash # 删除 test01 用户并删除家目录 [root@localhost ~]# ansible server -m user -a 'name=test01 state=absent remove=yes' Group模块 功能 管理用户组 示例 #创建组 ansible websrvs -m group -a 'name=nginx gid=88 system=yes' #删除组 ansible websrvs -m group -a 'name=nginx state=absent' Lineinfile模块 功能 相当于sed，可以修改文件内容。 ansible在使用sed进行替换时，经常会遇到需要转义的问题，而且ansible在遇到特殊符号进行替换时，存在问题，无法正常进行替换 。其实在ansible自身提供了两个模块：lineinfile模块和replace模块，可以方便的进行替换 示例 ansible all -m lineinfile -a \"path=/etc/selinux/config regexp='^SELINUX=' line='SELINUX=enforcing'\" ansible all -m lineinfile -a 'dest=/etc/fstab state=absent regexp=\"^#\"' Replace模块 功能 该模块有点类似于sed命令，主要也是基于正则进行匹配和替换 示例 ansible all -m replace -a \"path=/etc/fstab regexp='^(UUID.*)' replace='#\\1'\" ansible all -m replace -a \"path=/etc/fstab regexp='^#(.*)' replace='\\1'\" Setup模块 功能 setup 模块来收集主机的系统信息，这些 facts 信息可以直接以变量的形式使用，但是如果主机较多，会影响执行速度，可以使用 gather_facts: no 来禁止 Ansible 收集 facts 信息 常见参数 参数 说明 filter 按照key过滤输出结果，支持通配符 gather_timeout 设置收集数据的超时时间 示例 [root@localhost ~]# ansible server -m setup -a 'filter=ansible_virtualization_type' 10.91.156.205 | SUCCESS => { \"ansible_facts\": { \"ansible_virtualization_type\": \"kvm\", \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false } 可不加filter获取全部信息后，找到自己所需的字段，再通过filter方式获取指定字段 "},"ansible/Playbook.html":{"url":"ansible/Playbook.html","title":"Playbook","keywords":"","body":"参考 bilibili马哥视频 运维派教程 介绍 在Playbook中，使用task来定义一个子任务，并在任务中指定需要使用的模块，以及触发条件等信息。最终一个Playbook的Yml文件中可由多个task组成，按照任务顺序对指定主机进行自动化运维 YAML语言 教程 https://www.runoob.com/w3cnote/yaml-intro.html 核心元素 Hosts 执行的远程主机列表 remote_user：指定执行任务时在远程主机上所用的用户 Tasks 任务集 Variables 内置变量或自定义变量在playbook中调用 Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件 Handlers 和 notify 结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行 tags 标签 指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断 注：hosts用于指定要执行指定任务的主机，须事先定义在主机清单中 playbook命令 格式 ansible-playbook ... [options] 常见选项 -C --check #只检测可能会发生的改变，但不真正执行操作 --list-hosts #列出运行任务的主机 --list-tags #列出tag --list-tasks #列出task --limit 主机列表 #只针对主机列表中的主机执行 -v -vv -vvv #显示过程 playbook初步 开启远程主机mysql的远程访问权限 [root@localhost playbook]# cat config-mysql.yml --- - hosts: csmp gather_facts: no tasks: - name: Open mysql remote access permissions replace: path=/etc/my.cnf.d/server.cnf regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true - name: restart mysql service: name=mysql state=restarted 执行 [root@localhost playbook]# ansible-playbook config-mysql.yml -vv handlers和notify 作用 只有当关注的资源发生变化时，才会采取一定的操作。在notify中列出的操作成为handler 示例 改写上面的例子，只有当配置文件修改的时候才重启mysql服务 --- - hosts: csmp gather_facts: no tasks: - name: Open mysql remote access permissions replace: path=/etc/my.cnf.d/server.cnf regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted tags组件 作用 在playbook中，可以利用tags组件，为特定task指定标签，当在执行playbook时，可以只执行特定tags的tasks，而非整个playbook文件 示例 --- - hosts: csmp gather_facts: no tasks: - name: Open mysql remote access permissions replace: path=/etc/my.cnf.d/server.cnf regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true tags: replace - name: restart mysql service: name=mysql state=restarted tags: effective 此时就可只通过tags执行其中某一个task [root@localhost playbook]# ansible-playbook config-mysql.yml --list-tags playbook: config-mysql.yml play #1 (csmp): csmp TAGS: [] TASK TAGS: [effective, replace] # -t TAGS, --tags TAGS only run plays and tasks tagged with these values [root@localhost playbook]# ansible-playbook -t effective config-mysql.yml ansible中使用变量 定义 仅能由字母、数字和下划线组成，且只能以字母开头 variable=value 调用 通过 调用变量，且变量名前后建议加空格，有时用“”才生效 使用setup模块中变量 要求在playbook中使用，不要用ansible命令调用 --- #var.yml - hosts: all remote_user: root gather_facts: yes tasks: - name: create log file file: name=/data/.log state=touch owner=wang mode=600 ansible-playbook var.yml 在playbook命令行中定义变量 通过-e参数使用 -e EXTRA_VARS, --extra-vars EXTRA_VARS set additional variables as key=value or YAML/JSON, if filename prepend with @ 示例： --- - hosts: \"\" gather_facts: no tasks: - name: Open mysql remote access permissions replace: path=/etc/my.cnf.d/server.cnf regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted 在执行时通过-e指定server变量。 [root@localhost playbook]# ansible-playbook config-mysql.yml -e server=10.47.119.156 在playbook文件中定义变量 vars中定义变量，在后续直接使用 --- - hosts: \"\" gather_facts: no vars: - path: /etc/my.cnf.d/server.cnf tasks: - name: Open mysql remote access permissions replace: path= regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted 使用变量文件 可以在一个独立的playbook文件中定义变量，在另一个playbook文件中引用变量文件中的变量，比playbook中定义的变量优先级高 # 定义变量文件 [root@localhost playbook]# cat config-mysql-var.yml --- server_conf_path: /etc/my.cnf.d/server.cnf # playbook文件中引入使用 [root@localhost playbook]# cat config-mysql.yml --- - hosts: \"\" gather_facts: no vars_files: - config-mysql-var.yml tasks: - name: Open mysql remote access permissions replace: path= regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted 主机清单文件中定义变量 主机（普通）变量 在inventory主机清单文件中为指定得主机定义变量，以便在playbook中使用 [root@localhost playbook]# cat /etc/ansible/hosts [server] 10.47.119.156 server_conf_path=/etc/my.cnf.d/server.cnf 10.47.119.157 server_conf_path=/etc/my.cnf.d/server1.cnf 组（公共）变量 在inventory 主机清单文件中赋予给指定组内所有主机上的在playbook中可用的变量，如果和主机变是同名，优先级低于主机变量 [root@localhost playbook]# cat /etc/ansible/hosts [server] 10.47.119.156 10.47.119.157 [server:vars] server_conf_path=/etc/my.cnf.d/server.cnf 使用时直接使用变量即可 --- - hosts: \"\" gather_facts: no tasks: - name: Open mysql remote access permissions replace: path= regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted template模板 jinja2语言 官网：https://jinja.palletsprojects.com/en/2.11.x/ template 功能 可以根据和参考模块文件，动态生成相类似的配置文件 要求 template文件必须存放于templates目录下，且命名为 .j2 结尾 yaml/yml文件需和templates目录平级，目录结构如下示例： . ├── config.yml └── templates └── nginx.conf.j2 示例 # tree . ├── config-nginx.yml └── templates └── nginx.conf.j2 设置nginx进程数与ansible_processor_vcpus+1相等 # cat templates/nginx.conf.j2 ... worker_processes NaN; ... playbook内容 # cat config-nginx.yml --- - hosts: vm tasks: - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: restart nginx handlers: - name: restart nginx service: name=nginx state=restarted 使用setup模块发现ansible_processor_vcpus值为4，所以模板文件中对应nginx子进程数应为5 # ansible vm -m setup -a 'filter=ansible_processor_vcpus' 10.91.156.205 | SUCCESS => { \"ansible_facts\": { \"ansible_processor_vcpus\": 4, \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false } 统计nginx子进程数目 # ansible vm -m 'shell' -a \"ps aux | grep 'nginx: worker process' \" 10.91.156.205 | CHANGED | rc=0 >> nginx 24585 0.0 0.0 105956 3444 ? S 15:05 0:00 nginx: worker process nginx 24586 0.0 0.0 105956 3444 ? S 15:05 0:00 nginx: worker process nginx 24587 0.0 0.0 105956 3444 ? S 15:05 0:00 nginx: worker process nginx 24588 0.0 0.0 105956 3444 ? S 15:05 0:00 nginx: worker process nginx 24589 0.0 0.0 105956 3448 ? S 15:05 0:00 nginx: worker process ... 流程控制 template中可使用流程控制 for 循环和 if 条件判断，实现动态生成文件功能 for循环 示例 j2文件： ... ... playbook文件中src指定j2文件，拷贝到远程主机后记得要修改名称 --- - hosts: vm gather_facts: no vars: listen_ports: - 8888 - 8889 tasks: - name: template config to remote hosts template: src=nginx-server.conf.j2 dest=/etc/nginx/nginx.conf backup=true notify: restart nginx handlers: - name: restart nginx service: name=nginx state=restarted 验证发现服务器nginx.cnf中多出了8888，8889两个server ... server { listen 8888; root /usr/share/nginx/html; location / { } } server { listen 8889; root /usr/share/nginx/html; location / { } } .... 若vars中变量是字典形式，形如 vars: nginx_vhosts: - listen: 8080 server_name: \"web1.magedu.com\" root: \"/var/www/nginx/web1/\" - listen: 8081 server_name: \"web2.magedu.com\" root: \"/var/www/nginx/web2/\" jinja2就需要使用如下方式调用 if 判断 在模板文件中可通过条件判断，来决定相关配置得生成信息。例如 # cat if-config.yml --- - hosts: vm gather_facts: no vars: nginx_vhosts: - listen: 80 server_name: \"server1\" root: \"/var/www/nginx/web1\" - listen: 8080 root: \"var/www/nginx/web2\" tasks: - name: template config if exp template: src=if-config.cnf.j2 dest=/root/if-config.cnf 模板文件 最终生成结果 #结果 server { listen 80 server_name server1 root /var/www/nginx/web1 } server { listen 8080 root var/www/nginx/web2 } playbook使用when when语句，可实现条件测试。如果需要根据变量，facts或此前任务得执行结果来作为某task执行与否的前提时要用到条件测试。通过在task后添加when子句即可使用条件测试。 示例 如果ansible_os_family值为RedHat则创建/root/redhat目录，否则创建/root/others目录 --- - hosts: vm tasks: - name: mkdir redhat dir shell: mkdir /root/redhat when: ansible_os_family == \"RedHat\" - name: mkdir other dir shell: mkdir /root/otherOs when: ansible_os_family != \"RedHat\" 迭代with_items 作用 当有需要重复性执行的任务时，可以使用迭代机制。对迭代项的引用，固定变量名为\"item\"。要在task中使用with_items给定要迭代的元素列表 列表元素格式 字符串 --- - hosts: vm gather_facts: no tasks: - name: install tools yum: name= state=installed with_items: - lrzsz - wget 等同于 --- - hosts: vm gather_facts: no tasks: - name: install lrzsz yum: name=lrzsz state=installed - name: install wget yum: name=wget state=installed 字典 --- - hosts: vm gather_facts: no tasks: - name: copy config file copy: src= dest= with_items: - { src: /root/src1.cnf, dest: /root/dest1.txt } - { src: /root/src2.cnf, dest: /root/dest2.txt } "},"ansible/roles角色.html":{"url":"ansible/roles角色.html","title":"Roles","keywords":"","body":"参考 bilibili马哥视频 运维派教程 介绍 roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制 目录组织 ├──playbook.yml ├── roles │ ├── project │ ├── default │ ├── files │ ├── handlers │ ├── meta │ ├── tasks │ ├── templates │ └── vars 使用roles的playbook需要与roles文件目录平级，roles中目录作用如下 files/ ：存放由copy或script模块等调用的文件 templates/：template模块查找所需要模板文件的目录 tasks/：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含 handlers/：至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含 vars/：定义变量，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含 meta/：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，其它文件需在此文件中通过include进行包含 default/：设定默认变量时使用此目录中的main.yml文件，比vars的优先级低 示例1：实现httpd角色 目的 当引入httpd角色时，可以达到以下几个目的 为远程主机安装httpd并设置为开机自启动 将首页文件以及httpd配置文件拷贝到对应位置 重启服务生效 目录结构 . ├── role-install-httpd.yml ├── roles │ └── httpd │ ├── files │ │ ├── httpd.conf │ │ └── index.html │ ├── handlers │ │ └── main.yml │ └── tasks │ ├── config.yml │ ├── enable.yml │ ├── index.yml │ ├── install.yml │ └── main.yml playbbok内容 # cat role-install-httpd.yml - hosts: vm gather_facts: no roles: - httpd tasks内容 # cat roles/httpd/tasks/install.yml - name: install httpd package yum: name=httpd # cat roles/httpd/tasks/config.yml - name: config file copy: src=httpd.conf dest=/etc/httpd/conf/ backup=yes notify: restart # cat roles/httpd/tasks/index.yml - name: copy index copy: src=index.html dest=/var/www/html/ # cat roles/httpd/tasks/enable.yml - name: start service service: name=httpd state=started enabled=yes handlers内容 # cat roles/httpd/handlers/main.yml - name: restart service: name=httpd state=restarted 示例2：实现nginx角色 目的 在上一个例子的基础上增加templates以及vars。 配置文件由模板文件自动生成 nginx由指定的远程主机用户suhw启动 目录结构 ├── role-install-nginx.yml ├── roles │ └── nginx │ ├── handlers │ │ └── main.yml │ ├── tasks │ │ ├── config.yml │ │ ├── enable.yml │ │ ├── index.yml │ │ ├── install.yml │ │ └── main.yml │ ├── templates │ │ └── nginx.conf.j2 │ └── vars │ └── main.yml playbook内容 # cat role-install-nginx.yml - hosts: vm roles: - nginx tasks内容 # cat tasks/main.yml - include: install.yml - include: config.yml - include: index.yml - include: enable.yml # cat tasks/install.yml - name: install yum: name=nginx # cat tasks/config.yml - name: config nginx template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: restart # cat tasks/index.yml - name: copy index copy: src=roles/httpd/files/index.html dest=/usr/share/nginx/html # cat tasks/enable.yml - name: enable and start service service: name=nginx state=started enabled=yes templates内容 ... user ; worker_processes NaN; ... handlers内容 # cat handlers/main.yml - name: restart service: name=nginx state=restarted vars内容 cat vars/main.yml user: suhw "},"other/":{"url":"other/","title":"杂七杂八","keywords":"","body":"Other Note "},"other/GitBook搭建发布.html":{"url":"other/GitBook搭建发布.html","title":"GitBook搭建发布","keywords":"","body":"安装nodejs 直接安装10.21.0版本的，后续会省很多事。安装包地址 windows 直接下载对应的msi安装即可 Linux 选择自己适合的tar.gz包进行下载 tar -xzvf解压安装包 环境变量配置 PATH=$PATH:/root/node-v10.21.0-linux-x64/bin export PATH source /etc/profile 下载成功后通过node -V可进行验证 # node -v v10.21.0 安装gitbook 直接通过npm安装即可 npm install -g gitbook-cli 入门 创建一个存放文件的目录 # mkdir gitbook-home 初始化目录 # cd gitbook-home & gitbook init 启动服务进行测试 # gitbook serve ... Starting server ... Serving book on http://localhost:4000 访问本地4000端口即可查看到效果 上传文章 在gitbook-home目录下新建几个自己要上传文章的目录，方便文章分类。 # cat SUMMARY.md * [前言](README.md) * [Linux](linux/README.md) * [supervisor](linux/supervisor.md) * [vsftpd](linux/vsftpd.md) * [Ansible](ansible/README.md) * [Playbook](ansible/Playbook.md) * [Roles](ansible/roles角色.md) * [安装介绍](ansible/安装介绍.md) * [常用模块](ansible/常用模块.md) 配置插件 在gitbook_home目录下编辑book.json，若不存在则新建 { \"title\": \"suhw gitbook\", \"description\": \"suhw 学习笔记\", \"author\": \"suhaowei\", \"language\": \"zh-hans\", \"root\": \".\", \"plugins\": [ \"chapter-fold\", \"expandable-chapters\", \"lightbox\", \"-lunr\", \"-search\", \"search-pro\", \"splitter\", \"code\", \"anchor-navigation-ex\", \"github\", \"-highlight\", \"prism\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": false, \"showGoTop\": true }, \"github\": { \"url\": \"https://github.com/suhaow\" }, \"prism\": { \"css\": [ \"prismjs/themes/prism-okaidia.css\" ] } } } 插件用途 名称 作用 lightbox 图片放大 code 代码添加行号、添加复制按钮 search-pro 支持中文搜索，需去除默认的\"lunr\"以及\"search\" github 右上角添加github图标 splitter 侧边栏宽度可调节 chapter-fold 左侧目录折叠 expandable-chapters 左侧章节目录可折叠 prism 代码块高亮，去除默认的\"highlight\" anchor-navigation-ex 悬浮目录 更详细的可参考：https://blog.csdn.net/qq_43514847/article/details/86598399 部署到github github新建仓库。仓库名为 用户名.github.io 克隆仓库到本地 git clone git@github.com:suhaow/suhaow.github.io.git 输出书籍 cd suhaow.github.io.git & gitbook build ./ 上传书籍 git add . git commit -m \"add gitbook\" git push 稍等一下访问htttps://suhaow.github.io即可查看效果 参考 https://blog.csdn.net/meiko_zhang/article/details/81350924 https://www.bookstack.cn/read/gitbook-studying/publish-gitpages.md "},"linux/SSH信任关系.html":{"url":"linux/SSH信任关系.html","title":"SSH信任关系","keywords":"","body":"介绍 SSH（Secure Shell）是一项创建在应用层和传输层基础上得安全协议，为shell提供安全得传输和使用环境。具体协议以及服务相关知识不再赘述，下面主要介绍如何配置服务器之间的信任关系。以配置A免密登录到B为例 生成密钥 在A机器上通过ssh key-gen生成密钥 [root@suhw ~]# eval `ssh-agent -s` [root@suhw ~]# ssh-keygen -t rsa 若不指定存放密钥的路径以及名字的话，会默认生成在当前用户家目录下的.ssh目录中生成一个私钥和一个公钥 [root@suhw ~]# ll /root/.ssh/ -rw------- 1 root root 2590 Jun 28 15:41 id_rsa -rw-r--r-- 1 root root 563 Jun 28 15:41 id_rsa.pub 注：不可能每次生成密钥都覆盖掉之前的 ~/.ssh/id_rsa文件，建议在生成密钥第一步时指定文件名，便于区分管理 配置公钥 将生成的公钥追加到B机器的authorized_keys文件中 1、如果B机器.ssh目录下不存在authorized_keys文件，则通过touch命令新建，并将权限修改为600 [root@suhw ~]# cd ~/.ssh && touch authorized_keys && chmod 600 authorized_keys 2、将A机器生成的id_rsa》pub公钥追加到authorized_keys中 相关配置 ssh的配置文件包含以下两个： ~/.ssh/config：用户配置文件 /etc/ssh/ssh_config：系统配置文件 其中config配置中最常用的就是管理多组密钥对，对于多个服务器指定对应的密钥对，可以参考如下配置 HOST host1 # 关键词 User root # 登录用户名 HostName 10.47.119.96 # 主机名 IdentityFile /root/.ssh/host1_id_rsa # 私钥存储地址 HOST host2 User root HostName 10.47.119.97 IdentityFile /root/.ssh/host2_id_rsa 有了上面的配置，当我们在A机器上执行ssh host1时就会匹配到对应Host的配置，相当于执行了 ssh -i /root/.ssh/host1_id_rsa root@10.47.119.96 这样不论是ssh还是scp都会通过host匹配到对应的密钥文件进行连接，十分方便 配置项说明 Host：执行ssh命令时如果匹配到该配置，例如将HOST修改为kylin，在A机器上执行ssh kylin就相当于执行了ssh -i /data/suhw/.ssh/suhw_id_rsa root@10.44.103.165 HostName：主机地址 IdentityFile：指定读取的认证文件路径 其他具体参数可参考文章最后的链接 FAQ 1、若遇到报错Could not open a connection to your authentication agent. 先执行 eval ssh-agent -s 参考 https://deepzz.com/post/how-to-setup-ssh-config.html "},"linux/NFS配置.html":{"url":"linux/NFS配置.html","title":"NFS配置","keywords":"","body":"NFS介绍 介绍 NFS是Network FileSystem的缩写，主要功能是通过网络，让不同的机器，不同的操作系统，可以彼此分享指定的资源文件，可简单的认为是一个文件服务器，可以将远程NFS服务器共享的目录挂载到本地机器中，在本地机器看起来，被挂载的目录就像是自己的一个磁盘分区一样，使用非常方便。 上图中的NFS服务器设定好了要共享的目录后，其他客户端就可直接将该目录挂载到自己系统上的某个挂载点，就可通过挂载点直接访问服务器共享目录中的数据了（前提权限要够） NFS数据获取流程 背景 由于NFS支持的功能较多，不通的功能都会使用不同的程序来启动，而每一个程序都会启动一些端口来传输数据，所以NFS功能对应的端口没有固定，而是随机获取一些小于1024的端口来用。所以当客户端需要使用这些端口的时候，就需要远程过程调用(RPC)的服务了。当NFS服务器在启动时，会将随机获取来的端口都注册到RPC中，因为RPC知道每个端口对应的NFS功能，这样当客户端请求服务端时，只需要让监听在111端口的RPC服务来返回客户端正确的端口即可。 注：所以启动NFS之前，就需要启动RPC服务，否则NFS无法向RPC注册，同时当RPC重启时，旧的注册数据就会丢失，他管理的所有服务都需重新向RPC注册。 所以，当服务端将端口向RPC注册完成后，若有客户端有NFS数据存取需求时，执行流程如下： 客户端会向服务器端的 RPC (port 111)发出 NFS 档案存取功能的询问要求； 服务器端找到对应的已注册的端口后，会回报给客户端； 客户端了解正确的端口后，就可以直接与运行在该端口的程序来联机。 主要配置文件 默认配置文件地址：/etc/exports，该配置文件的内容需要自己手动写入 语法和参数 [root@suhw ~]# vim /etc/exports /tmp 192.168.100.0/24(ro) localhost(rw) *.ev.ncku.edu.tw(ro,sync) [分享目录] [第一部主机(权限)] [可用主机] [可用通配符] 详细的用户可参考示例。 权限参考参数，更全的介绍参考 man exports 参数值 内容说明 ro 该主机对共享目录权限为只读权限 rw 该主机对共享目录权限为读写权限 root_squash 客户端用root用户访问该共享文件夹时，将root用户映射为匿名用户 no_root_squash 客户端用root用户访问该共享文件夹时，不映射root用户，如果你想要开放客户端使用 root 身份来操作服务器的文件系统，那么这里就得要开 no_root_squash 才行！ all_squash 客户机上的任何用户访问该共享目录时都映射成匿名用户 anonuid 将客户机上的用户映射成指定的本地用户ID的用户 anongid 将客户机上的用户映射成属于指定的本地用户组ID sync 资料同步写入到内存与硬盘中 async 资料会先暂存于内存中，而非直接写入硬盘 insecure 允许从这台机器过来的非授权访问 举例 将/home/public公开，但是只有192.168.100.0/24这个网段的用户可以读写，其他来源只能读取 /home/public 192.168.100.0/24(rw) *(ro) 将/home/iso目录公开，允许所有人进行读操作 /home/iso *(ro,insecure,no_root_squash) 注意no_root_squash的功能。在这个例子中，如果你是客户端，而且你是以 root 的身份登入你的 Linux 主机，那么当你 mount 上我这部主机的/home/iso之后，你在该 mount 的目录当中，将具有root的权限！ exportfs指令 利用exportfs可以重新分享/etc/exports 变更的目录资源、将NFS Server分享的目录卸除或重新分享等等。 语法和参数 参数 作用 -a 打开或取消所有目录共享 -o options 指定一列共享选项 -i 忽略 /etc/exports 文件，只使用默认的和命令行指定的选项 -r 重新共享所有目录，使/etc/exportfs生效 -u 取消一个或多个目录的共享 -v 输出详细信息 -s 显示/etc/exports中的列表 查看分享资源记录 在NFS服务器的登陆文件都放置到/var/lib/nfs目录中，比较重要的有etab etab记录了NFS所分享出来的目录的完整权限设定值 /home/iso (ro,sync,wdelay,hide,nocrossmnt,insecure,no_root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,insecure,no_root_squash,no_all _squash) showmount指令 exportfs是用于在NFS server端维护分享的资源，而shownmount则是用于NFS client端，该命令可以查看出NFS server分享出的目录资源 语法和参数 showmount [ -adehv ] [ --all ] [ --directories ] [ --exports ] [ --help ] [ --version ] [ host ] 参数选项 作用 -d or --directories 显示已被nfs客户端加载的目录 -e or --exports 显示nfs服务端上所有的共享目录 挂载远程目录示例 NFS Server 配置 环境准备 要想对NFS server配置首先需要rpcbind和nfs-utils 可以使用rpm -qa | grep nfs-utils查询是否已经安装该软件，若没安装过执行下列命令 [root@suhw ~]# yum install -y nfs-utils rpcbind：NFS可被视为RPC服务，而启动RPC服务之前，我们首先需要启动rpcbind [root@suhw ~]# systemctl start rpcbind [root@suhw ~]# systemctl status rpcbind ● rpcbind.service - RPC bind service Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; enabled; vendor preset: enabled) Active: active (running) since Tue 2020-06-16 10:26:08 CST; 2s ago Process: 29537 ExecStart=/sbin/rpcbind -w $RPCBIND_ARGS (code=exited, status=0/SUCCESS) Main PID: 29538 (rpcbind) Tasks: 1 Memory: 660.0K CGroup: /system.slice/rpcbind.service └─29538 /sbin/rpcbind -w Jun 16 10:26:07 suhw systemd[1]: Starting RPC bind service... Jun 16 10:26:08 suhw systemd[1]: Started RPC bind service. 由于rpc固定使用111端口，所以可直接查看111端口是否处于监听状态 [root@suhw ~]# netstat -tulnp | grep 111 tcp6 0 0 :::111 :::* LISTEN 29538/rpcbind udp 0 0 0.0.0.0:111 0.0.0.0:* 29538/rpcbind udp6 0 0 :::111 :::* 29538/rpcbind 启动服务 确保rpcbind启动 #查看 rpcbind 状态 [root@suhw ~]# systemctl status rpcbind #若rpcbind未启动，则start [root@suhw ~]# systemctl start rpcbind 确保nfs启动 [root@suhw ~]# systemctl status nfs #若nfs未启动，则start [root@suhw ~]# systemctl start nfs 配置文件编写 允许10.91开头的地址共享/home/test目录，并具有可读可写操作 [root@suhw ~]# cat /etc/exports /home/test 10.91.*(rw,sync,no_root_squash) 配置文件生效 使用上面介绍的用来管理当前NFS共享的文件系统列表的exportfs命令 # 重新共享，使 exports 生效 [root@suhw ~]# exportfs -r [root@suhw ~]# exportfs -s /home/test 10.91.*(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,no_root_squash,no_all_squash) 验证 NFS服务端配置完成后，先在服务端通过showmount命令测试下是否已经共享成功 [root@suhw ~]# showmount -e localhost Export list for localhost: /home/test 10.91.* 此时查看之前说的`etab就会发现多了一条记录i [root@suhw ~]# cat /var/lib/nfs/etab /home/test 10.91.*(rw,sync,wdelay,hide,nocrossmnt,secure,no_root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,rw,secure,no_root_squash,no_all_squash) 在挂载目录下创建个文件，方便一会观察现象 [root@suhw ~]# touch /home/test/test.txt NFS Cient配置 环境验证 1、确认本地端已经启动了 rpcbind 服务 [root@nfs-client ~]# systemctl status rpcbind ● rpcbind.service - RPC bind service Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; enabled; vendor preset: enabled) Active: active (running) since Mon 2020-06-15 18:11:40 CST; 20h ago Main PID: 1264 (rpcbind) CGroup: /system.slice/rpcbind.service └─1264 /sbin/rpcbind -w Jun 15 18:11:40 csmp-SP1Fusion systemd[1]: Starting RPC bind service... Jun 15 18:11:40 csmp-SP1Fusion systemd[1]: Started RPC bind service. 2、确保安装showmount 查看远程服务器共享资源 [root@nfs-client ~]# showmount -e 10.91.156.174 Export list for 10.91.156.174: /home/test 10.91.*/ 进行挂载 1、在本地端建立预计要挂载的挂载点目录 [root@nfs-client ~]# mkdir -p /home/test 2、利用 mount 将远程主机直接挂载到相关目录 [root@nfs-client ~]# mount 10.91.156.174:/home/test /home/test 3、查看挂载信息 [root@nfs-client ~]# df -h Filesystem Size Used Avail Use% Mounted on ''' 10.91.156.174:/home/test 17G 8.0G 9.1G 47% /home/test 验证 查看本地挂载目录下的内容即可 [root@nfs-client ~]# ll /home/test/ total 0 -rw-r--r-- 1 root root 0 Jun 16 14:47 test.txt 取消挂载 若不需要挂载时，使用umount命令指定本地挂载目录即可 [root@nfs-client ~]# umount /home/test 参考 http://cn.linux.vbird.org/linux_server/0330nfs.php#What_NFS_0 "}}