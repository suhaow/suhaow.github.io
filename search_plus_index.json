{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction "},"linux/":{"url":"linux/","title":"Linux","keywords":"","body":"Linux Note "},"linux/supervisor.html":{"url":"linux/supervisor.html","title":"supervisor","keywords":"","body":"简介 Supervisor 是可以在类 UNIX 系统中进行管理和监控各种进程的小型系统。它自带了客户端和服务端工具。可以通过用户所定义的配置文件来管理和监控单个或多个进程，并且它可以根据配置来对异常崩溃的进程进行重启操作。 环境信息 [root@suhw ~]# cat /etc/redhat-release CentOS Linux release 7.7.1908 (Core) 安装 [root@suhw ~]# yum install epel-release [root@suhw ~]# yum install -y supervisor [root@suhw ~]# systemctl enable supervisord # 开机自启动 [root@suhw ~]# systemctl start supervisord # 启动supervisord服务 [root@suhw ~]# systemctl status supervisord # 查看supervisord服务状态 配置 配置选项可具体参考/etc/supervisord.conf中的详细介绍，或者可参考http://supervisord.org/ 若想新增要管理的进程，直接在supervisor的配置文件默认目录/etc/supervisord.d/下添加ini文件即可，在/etc/supervisord.conf中已定义会将/etc/supervisord.d/目录下所有的ini文件都会包含进来。 ... [include] files = supervisord.d/*.ini 管理redis 每个 program 代表了一个要进行管理的进程，我们可以在这里进行进程的相关配置。 编辑配置文件 假设此时需要使用supervisor管理redis-server，编辑/etc/supervisord.d/redis.ini # 项目名 [program:redis] # 脚本执行命令 command=/usr/bin/redis-server /etc/redis.conf # 当进程数为 1 时 为 %(program_name)s # 当进程数 >1 时 应配置为 %(program_name)s_%(process_num)02d process_name=%(program_name)s # 如果numprocs>1，supervisor启动当前program时会实例化好几个子进程，默认情况取1 numprocs=1 # supervisord作为守护进程的时候，会转换路径到该目录 directory=/suhw/data/redis # supervisord进程的文件权限掩码，默认 022 umask=022 # 进程启动优先级，默认999，值小的优先启动 priority=999 # supervisor启动时是否跟随同时启动(默认为true) autostart=true # 启动1秒后没有异常退出，就表示进程正常启动了，默认为1秒 startsecs=2 # 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启 autorestart=true # 启动失败自动重试次数，默认是3 startretries=100 # 脚本运行的用户身份 # user=csmp # 把stderr重定向到stdout，默认 false redirect_stderr=true # 日志输出 stdout_logfile=/suhw/data/redis/logs/%(program_name)s-stdout.log # stdout日志文件大小，默认 50MB stdout_logfile_maxbytes=10MB # stdout 日志文件备份数 stdout_logfile_backups=10 # 当进程处于stdout capture mode模式的时候，写入capture FIFO的最大字节数限制，默认为0，此时认为stdout capture mode模式关闭； stdout_capture_maxbytes=10MB 重新载入配置 # 重新加载配置并根据需要添加/删除，并将重新启动受影响的程序 [root@suhw ~]# supervisorctl update # 重新载入 supervisord [root@suhw ~]# supervisorctl reload 查看状态 [root@suhw ~]# supervisorctl status redis RUNNING pid 19573, uptime 0:00:18 此时redis服务已经被supervisor所接管了，我们以后就可通过supervisorctl进行服务的操作 supervisorctl操作 supervisorctl 是 supervisord 的命令行客户端工具，直接输入supervisorctl可进入交互界面，也可直接输入shell命令操作。 [root@suhw ~]# supervisorctl redis RUNNING pid 19573, uptime 0:20:06 supervisor> help default commands (type help ): ===================================== add exit open reload restart start tail avail fg pid remove shutdown status update clear maintail quit reread signal stop version supervisorctl可选参数如上，可以在交互模式中输入 help xxx查看对应命令的作用，举例如下 supervisor> help reload reload Restart the remote supervisord. "},"linux/vsftpd.html":{"url":"linux/vsftpd.html","title":"vsftpd","keywords":"","body":"FTP 介绍 FTP(File transfer protocol)在TCP/IP协议族中属于应用层协议运行于TCP协议之上是一种可靠的传输协议，主要功能用于实现用户间文件分发共享，以及网络管理者在进行设备版本升级、日志下载和配置保存等业务操作时，均会使用到FTP功能。 FTP不同于其他服务的是它使用了两个端口，一个数据端口（通常为20端口），一个命令端口，也称控制端口（通常为21端口） 传输模式 FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动模式和被动模式。其中是否主动是站在FTP服务端来讨论的，而选择使用哪种传输方式的选择权则是在FTP客户端。 主动模式 主动模式下，FTP客户端从任意的非特殊端口（N>1023）连入到FTP服务器的21命令端口，然后客户端在（N+1）端口监听，并且通过N+1端口发送PORT命令将N+1端口告知服务器，然后服务器会主动从自己的20数据端口发起到客户端告知的N+1端口的连接。连接成功后，开始传输数据。 被动模式 被动模式对应命令为 PASV（全称Passive）。在被动模式中，命令连接和数据连接都由客户端发起。当开启FTP连接时，客户端打开任意两个非特权端口（N>1023和N+1）。第一个端口连接服务器的21端口，并发送PASV命令告知服务器启动被动模式，服务端接收到PASV命令后，开启一个任意非特权端口（P>1024），并发送PORT P命令给客户端，然后由客户端主动从本地N+1到服务器的P端口的连接 区别 简单说 主动模式就是服务器 主动连接 到客户端的端口，而被动模式就是客户端主动连接服务器的端口，服务器负责开放端口后进行监听，等待客户端连接。 使用场景 当client端和server端同处一个局域网使用两种模式都不会存在问题， 但现实环境中无论是Client端还是Server端都是在防火墙后面，在主动模式下VSFTP会链接Client端的随机+1号端口，Client端显然不会将防火墙上所有随机端口开放；而在被动下问题同样的问题仍然会摆在Server端的防火墙面前，这就需要Server端的防火墙开启连接追踪功能，即放行与21号端口有关联的端口访问请求，这也就是为什么大部分情况下VSFTP是以被动模式工作。 Vsftpd 介绍 vsftpd(Very Secure FTP Daemon)，是一个以安全为主的FTP服务器 安装 [root@suhw ~]# yum install -y vsftpd 启动 # 启动 vsftpd [root@suhw ~]# systemctl start vsftpd # 查看状态 [root@suhw ~]# systemctl status vsftpd ● vsftpd.service - Vsftpd ftp daemon Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; disabled; vendor preset: disabled) Active: active (running) since Wed 2020-06-17 20:12:50 CST; 6s ago Process: 17277 ExecStart=/usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf (code=exited, status=0/SUCCESS) Main PID: 17278 (vsftpd) Tasks: 1 Memory: 648.0K CGroup: /system.slice/vsftpd.service └─17278 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf Jun 17 20:12:47 suhw systemd[1]: Starting Vsftpd ftp daemon... Jun 17 20:12:50 suhw systemd[1]: Started Vsftpd ftp daemon. 配置文件 文件地址 作用 /etc/vsftpd/vsftpd.conf vsftpd 配置文件 /etc/pam.d/vsftpd vsftpd 使用 pam 时的相关破欸之 /etc/vsftpd/ftpusers 记录着 拒绝登录ftp 的账号 /etc/vsftpd/user_list 记录需要管理的 vsftpd 用户账号 ，与 vsftpd.conf 中的 userlist_anle，userlist_deny 有关，控制列表中的用户是否可登录 vsftpd 账号 /etc/vsftpd/chroot_list 将指定用户 chroot 在对应的家目录下，与vsftpd.conf 中的 chroot_list_enable 和 chroot_list_file 有关 /var/ftp vsftpd 预设匿名者登录的根目录 参数介绍 下面只列举/etc/vsftpd/vsftpd.conf中部分参数介绍，详细介绍参考man 5 vsftpd.conf 参数 作用 anonymous_enable=NO 是否允许匿名帐户登录 FTP 服务器 local_enable=YES 是否允许本地账户登录 FTP 服务器 write_enable =YES 是否开启目录上次权限 local_umask=022 本地用户上传文件的权限掩码 目录消息 dirmessage_enable=YES 用户第一次进入目录时，vsftpd会查看.message文件，并将其内容显示给用户 message_file 指定文件路径，而非默认的.message 数据传输日志 xferlog_enable=YES 是否开启日志功能 xferlog_file=/var/log/vsftpd.log 日志的存放路径 xferlog_std_format=No 日志的格式 数据传输模式 connect_from_port_20=YES 是否启用PORT模式 chroot_local_user=YES 修改匿名用户上传的文件的属主 chown_uploads 是否修改 chown_username 启用chown_uploads指令时，将文件属主修改为此指令指定的用户，默认为root chown_upload_mode 设置匿名用户上传文件的权限，默认600 设定会话超时时长 idle_session_timeout 空闲会话超时时长 connect_timeout prot模式下，服务器连接客户端的超时时长 data_connection_timeout 数据传输的超时时长 与主机相关的设定值 listen_port 默认为21 listen 若设定为YES 表示 vsftpd 以standalone 方式启动，默认为No 设定连接及传输速率 local_max_rate 本地用户的最大传输速率 anon_max_rate 匿名用户的最大传输速率 max_clients 最大并发连接数 max_per_ip 每个ip所允许发起的最大连接数 禁锢本地用户 chroot_local_user 是否禁锢所有本地用户 chroot_list_enable 用户访问控制 userlist_enable 若置为开启，vsftpd将加载由userlist_file指令指定的用户列表文件，此文件中的用户是否能访问vsftpd服务取决于userlist_deny指令； userlist_deny 表示此列表是否为黑名单(YES表示为黑名单，反之为白名单) pasv_enable 值为 YES 表示启动被动模式 pasv_min_port=0 pasv_max_port=0 设定被动模式所用的端口号，0代表随机取用 pasv_address 设置ftp服务器返回的pasv地址 被动模式配置 上面介绍了两种传输模式的区别以及各自应用场景，实际开发过程中被动模式十分常见，相关的配置可参考如下： # 启用被动模式 pasv_enable=YES # 随机端口所用的端口号范围 pasv_min_port=6000 pasv_max_port=7000 #指定被动模式回传的服务器IP地址 pasv_address=10.44.192.126 # 指定vsftpd侦听的地址为非IPv6格式 listen_ipv6=NO # 以 standalone 方式启动 listen=YES 参考 http://linux.vbird.org/linux_server/0410vsftpd.php https://yq.aliyun.com/articles/545714 http://blog.sina.com.cn/s/blog_946cb2b70100x4zc.html "},"ansible/":{"url":"ansible/","title":"Ansible","keywords":"","body":"Ansible Note "},"ansible/安装介绍.html":{"url":"ansible/安装介绍.html","title":"安装介绍","keywords":"","body":"参考 bilibili马哥视频 运维派教程 介绍 ansible是一种自动化运维工具，基于Python开发，可实现批量系统配置、批量程序部署、批量运行命令等功能。 环境信息 # hostnamectl Static hostname: localhost.localdomain Icon name: computer-vm Chassis: vm Machine ID: 752d91f949a840fa9f2ed0b2ca54d8ad Boot ID: 81088a1ae25a46279b7746e8c9e0a091 Virtualization: vmware Operating System: CentOS Linux 7 (Core) CPE OS Name: cpe:/o:centos:centos:7 Kernel: Linux 3.10.0-957.el7.x86_64 Architecture: x86-64 安装 可直接通过yum安装 [root@localhost ~]# yum search ansible 校验 [root@localhost ~]# ansible --version ansible 2.9.15 config file = /etc/ansible/ansible.cfg configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python2.7/site-packages/ansible executable location = /usr/bin/ansible python version = 2.7.5 (default, Oct 30 2018, 23:45:53) [GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] 常用工具 名称 用途 ansible 主程序，临时命令执行工具 ansible-doc 查看配置文档，模块功能查看工具 ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台 ansible-playbook 定制自动化任务，编排剧本工具 ansible-pull 远程执行命令的工具 ansible-vault 文件加密工具 ansible-console 基于Console界面与用户交互的执行工具 ansible-doc 格式 ansible-doc [options] [module...] -l, --list #列出可用模块 -s, --snippet #显示指定模块的playbook片段 例如查看ping模块的简短文档 [root@localhost ~]# ansible-doc -s ping - name: Try to connect to host, verify a usable python and return `pong' on success ping: data: # Data to return for the `ping' return value. If this parameter is set to `crash', the module will cause an exception. ansible 格式 ansible [-m module_name] [-a args] --version #显示版本 -m module #指定模块，默认为command -v #详细过程 –vv -vvv更详细 --list-hosts #显示主机列表，可简写 --list -k, --ask-pass #提示输入ssh连接密码，默认Key验证 -C, --check #检查，并不执行 -T, --timeout=TIMEOUT #执行命令的超时时间，默认10s -u, --user=REMOTE_USER #执行远程执行的用户 -b, --become #代替旧版的sudo 切换 --become-user=USERNAME #指定sudo的runas用户，默认为root -K, --ask-become-pass #提示输入sudo时的口令 注：若执行-k，必须所有hosts中主机密码相同，否则可能会出现失败 示例 [root@localhost ~]# ssh-keygen [root@localhost ~]# ssh-copy-id 10.91.156.209 [root@localhost ~]# ssh-copy-id 10.91.156.205 # 此时公钥已被添加到209 205两台机器中的root用户下 [root@localhost ~]# ansible all -m ping 10.91.156.209 | SUCCESS => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } 10.91.156.205 | SUCCESS => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } 查看所有hosts [root@localhost ~]# ansible all --list-hosts hosts (2): 10.91.156.205 10.91.156.209 [root@localhost ~]# ansible server --list-hosts hosts (1): 10.91.156.209 [root@localhost ~]# ansible node --list-hosts hosts (1): 10.91.156.205 [root@localhost ~]# cat /etc/ansible/hosts [server] 10.91.156.209 [node] 10.91.156.205 ansible命令执行过程 加载自己的配置文件 默认/etc/ansible/ansible.cfg 加载自己对应的模块文件，如：command 通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件 给文件+x权限执行 执行并返回结果 删除临时py文件，退出 具体过程可通过-vvv参数来详细查看 [root@localhost ~]# ansible server -vvv -m ping > ansible.log # 增加执行权限记录 [root@localhost ~]# grep -n chmod ansible.log 31: SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/4f24120d2d 10.91.156.209 '/bin/sh -c '\"'\"'chmod u+x /root/.ansible/tmp/ansible-tmp-1608777830.06-12031-172335200139721/ /root/.ansible/tmp/ansible-tmp-1608777830.06-12031-172335200139721/AnsiballZ_ping.py && sleep 0'\"'\"'' #删除临时文件 [root@localhost ~]# grep -n chmod ansible.log ... 37: SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/4f24120d2d 10.91.156.209 '/bin/sh -c '\"'\"'rm -f -r /root/.ansible/tmp/ansible-tmp-1608777830.06-12031-172335200139721/ > /dev/null 2>&1 && sleep 0'\"'\"'' 查找ansible.cfg顺序 ANSIBLE_CONFIG：首先，Ansible命令会检查环境变量，及这个环境变量将指向的配置文件 ./ansible.cfg：其次，将会检查当前目录下的ansible.cfg配置文件 ~/.ansible.cfg：再次，将会检查当前用户home目录下的.ansible.cfg配置文件 /etc/ansible/ansible.cfg：最后，将会检查在用软件包管理工具安装Ansible时自动产生的配置文件 ansible-galaxy 此工具会连接 https://galaxy.ansible.com 下载相应的roles 示例 #列出所有已安装的galaxy ansible-galaxy list #安装galaxy ansible-galaxy install geerlingguy.mysql ansible-galaxy install geerlingguy.redis #删除galaxy ansible-galaxy remove geerlingguy.redis ansible-playbook 作用 此工具用于执行编写好的 playbook任务 示例 [root@localhost ~]# cat hello.yml - hosts: server remote_user: root tasks: - name: hello world command: /usr/bin/wall hello world 执行结果 ansible-vault 作用 此工具可以用于加密解密yml文件 示例 ansible-vault encrypt hello.yml #加密 ansible-vault decrypt hello.yml #解密 ansible-vault view hello.yml #查看 ansible-vault edit hello.yml #编辑加密文件 ansible-vault rekey hello.yml #修改口令 ansible-vault create new.yml #创建新文件 ansible-console 此工具可交互执行命令，支持tab，ansible 2.0+新增 提示符格式： 执行用户@当前操作的主机组 (当前组的主机数量)[f:并发数]$ 常用子命令 设置并发数： forks n 例如： forks 10 切换组： cd 主机组 例如： cd web 列出当前组主机列表： list 列出所有的内置命令： ?或help 范例 [root@ansible ~]#ansible-console Welcome to the ansible console. Type help or ? to list commands. root@all (3)[f:5]list 10.0.0.8 10.0.0.7 10.0.0.6 root@all (3)[f:5] cd websrvs root@websrvs (2)[f:5]list 10.0.0.7 10.0.0.8 root@websrvs (2)[f:5] forks 10 root@websrvs (2)[f:10]cd appsrvs root@appsrvs (2)[f:5] yum name=httpd state=present root@appsrvs (2)[f:5]$ service name=httpd state=started 其它 输出颜色代表含义 ansible执行完任务后，会根据不同的颜色来说明执行的结果，默认颜色的含义如下（在/etc/ansible/ansible.cfg中）。其中最常见的就是红黄绿三种颜色。 [colors] #highlight = white #verbose = blue #warn = bright purple # 执行失败 #error = red #debug = dark gray #deprecate = purple #skip = cyan #unreachable = red #ok = green # 执行成功并且对目标主机做变更 #changed = yellow # 执行成功并且不需要做改变的操作 #diff_add = green #diff_remove = red #diff_lines = cyan "},"ansible/常用模块.html":{"url":"ansible/常用模块.html","title":"常用模块","keywords":"","body":"参考 bilibili马哥视频 运维派教程 基础配置 [root@localhost ~]# cat /etc/ansible/hosts [server] 10.91.156.209 [node] 10.91.156.205 Command模块 功能 在远程主机执行命令，此为默认模块，可忽略-m选项 注意：此命令不支持 $VARNAME | ; & 等，用shell模块实现 文档 [root@localhost ~]# ansible-doc -s command - name: Execute commands on targets command: argv: # Passes the command as a list rather than a string. Use `argv' to avoid quoting values that would otherwise be interpreted incorrectly (for example \"user name\"). Only the string or the list form can be provided, not both. One or the other must be provided. chdir: # Change into this directory before running the command. cmd: # The command to run. creates: # A filename or (since 2.0) glob pattern. If it already exists, this step *won't* be run. free_form: # The command module takes a free form command to run. There is no actual parameter named 'free form'. removes: # A filename or (since 2.0) glob pattern. If it already exists, this step *will* be run. stdin: # Set the stdin of the command directly to the specified value. stdin_add_newline: # If set to `yes', append a newline to stdin data. strip_empty_ends: # Strip empty lines from the end of stdout/stderr in result. warn: # Enable or disable task warnings. 示例 # 切换到/etc目录下 查看centos-release [root@localhost ~]# ansible server -m command -a 'chdir=/etc cat centos-release' 10.91.156.209 | CHANGED | rc=0 >> CentOS Linux release 7.6.1810 (Core) Shell模块 功能 和command相似，用shell执行命令 注意：调用bash执行命令 类似cat /tmp/test.md | awk -F‘|’ ‘{print 1,1,1,2}’ &> /tmp/example.txt这些复杂命令，即使使用shell也可能会失败，解决办法：写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器 文档 [root@localhost ~]# ansible-doc -s shell - name: Execute shell commands on targets shell: chdir: # Change into this directory before running the command. cmd: # The command to run followed by optional arguments. creates: # A filename, when it already exists, this step will *not* be run. executable: # Change the shell used to execute the command. This expects an absolute path to the executable. free_form: # The shell module takes a free form command to run, as a string. There is no actual parameter named 'free form'. See the examples on how to use this module. removes: # A filename, when it does not exist, this step will *not* be run. stdin: # Set the stdin of the command directly to the specified value. stdin_add_newline: # Whether to append a newline to stdin data. warn: # Whether to enable task warnings. 示例 将shell模块代替command，设为默认模块。编辑/etc/ansible/ansible.cfg文件 # default module name for /usr/bin/ansible #module_name = command module_name = shell 打印主机的hostname。对比发现command模块输出有问题，shell可以正常打印 [root@localhost ~]# ansible server -m command -a 'echo $HOSTNAME' 10.91.156.209 | CHANGED | rc=0 >> $HOSTNAME [root@localhost ~]# ansible server -m shell -a 'echo $HOSTNAME' 10.91.156.209 | CHANGED | rc=0 >> node Script模块 功能 在远程主机上运行ansible服务器上的脚本 文档 [root@localhost ~]# ansible-doc -s script - name: Runs a local script on a remote node after transferring it script: chdir: # Change into this directory on the remote node before running the script. cmd: # Path to the local script to run followed by optional arguments. creates: # A filename on the remote node, when it already exists, this step will *not* be run. decrypt: # This option controls the autodecryption of source files using vault. executable: # Name or path of a executable to invoke the script with. free_form: # Path to the local script file followed by optional arguments. removes: # A filename on the remote node, when it does not exist, this step will *not* be run. 示例 [root@localhost ~]# cat test.sh #!/bin/sh echo sever HostName is `hostname` [root@localhost ~]# ansible server -m script -a 'test.sh' 10.91.156.209 | CHANGED => { \"changed\": true, \"rc\": 0, \"stderr\": \"Shared connection to 10.91.156.209 closed.\\r\\n\", \"stderr_lines\": [ \"Shared connection to 10.91.156.209 closed.\" ], \"stdout\": \"sever HostName is node\\r\\n\", \"stdout_lines\": [ \"sever HostName is node\" ] } Copy模块 功能 从ansible服务器主控端复制文件到远程主机 [root@localhost ~]# ansible-doc -s copy - name: Copy files to remote locations copy: ..... 示例 #如目标存在，默认覆盖，此处指定先备份 ansible websrvs -m copy -a “src=/root/test1.sh dest=/tmp/test2.sh owner=wang mode=600 backup=yes” #指定内容，直接生成目标文件 ansible websrvs -m copy -a \"content='test line1\\ntest line2' dest=/tmp/test.txt\" #复制/etc/下的文件，不包括/etc/目录自身 ansible websrvs -m copy -a “src=/etc/ dest=/backup” Fetch模块 功能 从远程主机提取文件至ansible的主控端，copy相反，目前不支持目录 File模块 功能 设置文件属性 常见参数 参数 含义 group 文件所属组 mode 文件权限 owner 文件拥有者 path 需要管理的文件路径（必选） recurse 递归设置（当state取值为directory） src 文件的链接地址 （只当state值为link或hard时设置） state absent：目录会递归删除，文件会被删除，符号链接会被取消链接 directory：创建目录hard 创建或修改硬链接 link 创建或修改软链接 touch：如果path指定的文件不存在，则创建 示例 [root@localhost ~]# ansible server -m file -a 'path=/root/test.txt state=touch' 10.91.156.209 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"dest\": \"/root/test.txt\", \"gid\": 0, \"group\": \"root\", \"mode\": \"0644\", \"owner\": \"root\", \"secontext\": \"unconfined_u:object_r:admin_home_t:s0\", \"size\": 0, \"state\": \"file\", \"uid\": 0 } [root@localhost ~]# ansible server -a 'ls -l' 10.91.156.209 | CHANGED | rc=0 >> ... -rw-r--r--. 1 root root 0 12月 24 16:51 test.txt unarchive模块 功能 解包解压缩 实现有两种用法： 1、将ansible主机上的压缩包传到远程主机后解压缩至特定目录，设置copy=yes 2、将远程主机上的某个压缩包解压缩到指定路径下，设置copy=no 常见参数 copy：默认为yes，当copy=yes，拷贝的文件是从ansible主机复制到远程主机上，如果设置为copy=no，会在远程主机上寻找src源文件 remote_src：和copy功能一样且互斥，yes表示在远程主机，不在ansible主机，no表示文件在ansible主机上 src：源路径，可以是ansible主机上的路径，也可以是远程主机上的路径，如果是远程主机上的路径，则需要设置copy=no dest：远程主机上的目标路径 mode：设置解压缩后的文件权限 示例 # 创建压缩包 [root@localhost ~]# tar -czvf testDir.tar.gz testDir/ testDir/ testDir/test.sh # 将压缩包拷至远程主机 /root 目录下并解压 [root@localhost ~]# ansible server -m unarchive -a 'src=./testDir.tar.gz dest=/root copy=yes' 10.91.156.209 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"dest\": \"/root\", \"extract_results\": { \"cmd\": [ \"/usr/bin/gtar\", \"--extract\", \"-C\", \"/root\", \"-z\", \"-f\", \"/root/.ansible/tmp/ansible-tmp-1608812600.88-13937-63576563579965/source\" ], \"err\": \"\", \"out\": \"\", \"rc\": 0 }, \"gid\": 0, \"group\": \"root\", \"handler\": \"TgzArchive\", \"mode\": \"0550\", \"owner\": \"root\", \"secontext\": \"system_u:object_r:admin_home_t:s0\", \"size\": 244, \"src\": \"/root/.ansible/tmp/ansible-tmp-1608812600.88-13937-63576563579965/source\", \"state\": \"directory\", \"uid\": 0 } # 查看远程主机解压结果 [root@localhost ~]# ansible server -a 'ls -l /root/testDir/' 10.91.156.209 | CHANGED | rc=0 >> 总用量 4 -rwxr-xr-x. 1 root root 47 12月 24 14:31 test.sh Archive模块 功能 打包压缩 示例 # 将目标主机 /roor/testDir 目录压缩至 /root/testDir.tar.gz 权限为 644 [root@localhost ~]# ansible server -m archive -a 'path=/root/testDir/ dest=/root/testDir.tar.gz format=gz mode=644' 10.91.156.209 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"archived\": [ \"/root/testDir/test.sh\" ], \"arcroot\": \"/root/testDir/\", \"changed\": true, \"dest\": \"/root/testDir.tar.gz\", \"expanded_exclude_paths\": [], \"expanded_paths\": [ \"/root/testDir/\" ], \"gid\": 0, \"group\": \"root\", \"missing\": [], \"mode\": \"0644\", \"owner\": \"root\", \"secontext\": \"unconfined_u:object_r:admin_home_t:s0\", \"size\": 175, \"state\": \"file\", \"uid\": 0 } [root@localhost ~]# ansible server -a 'ls -l /root' 10.91.156.209 | CHANGED | rc=0 >> ... -rw-r--r--. 1 root root 175 12月 24 21:48 testDir.tar.gz Hostname模块 功能 管理主机名 参数 参数 说明 name （必填）主机名称 use 更新策略 示例 ansible server -m hostname -a “name=suhw” Cron模块 功能 计划任务 常用参数 参数 含义 minute 分 hour 小时 day 日 month 月 weekday 作业应该在一周的哪一天运行(周日-周六为0-6) job 任务路径 disabled 是否禁用任务 user 应该修改crontab的特定用户。如果没有设置，这个参数默认使用' root'。 示例 # 脚本内容：输出当前时间至log文件 [root@localhost ~]# cat /root/date.sh #/!/bin/sh date >> /root/date.log # 先拷贝到目标主机上 [root@localhost ~]# ansible server -m copy -a \"src=./date.sh dest=/root/date.sh mode=755\" # 将脚本每分钟执行一次 [root@localhost ~]# ansible server -m cron -a \"job=/root/date.sh minute=*/1 name=GetDate\" 10.91.156.205 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"envs\": [], \"jobs\": [ \"GetDate\" ] } # 查看目标主机定时任务列表 [root@localhost ~]# ansible server -a 'crontab -l' 10.91.156.205 | CHANGED | rc=0 >> #Ansible: GetDate */1 * * * * /root/date.sh # 查看执行结果 [root@localhost ~]# ansible server -a 'cat /root/date.log' 10.91.156.205 | CHANGED | rc=0 >> Fri Dec 25 19:48:01 CST 2020 # 使用 disabled 属性取消该任务 [root@localhost ~]# ansible server -m cron -a \"job=/root/date.sh minute=*/1 name=GetDate disabled=true\" 10.91.156.205 | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"envs\": [], \"jobs\": [ \"GetDate\" ] } # 再次查看发现已经注释取消 [root@localhost ~]# ansible server -a 'crontab -l' 10.91.156.205 | CHANGED | rc=0 >> #Ansible: GetDate #*/1 * * * * /root/date.sh Yum模块 功能 管理软件包，只支持RHEL，CentOS，fedora，不支持Ubuntu其它版本 常用参数 参数 含义 name 包名或带有版本的包说明符，如' name-1.0'。 state 可选：absent, installed, latest, present, removed Service模块 功能 管理服务 常见参数 参数 含义 name 包名或带有版本的包说明符，如' name-1.0'。 state 可选：started 、stopped 、 restarted 、 reloaded enabled 是否开机启动 示例 # 关闭远程主机docker服务 [root@localhost ~]# ansible server -m service -a 'name=docker state=stopped' User模块 功能 管理用户 示例 # 添加用户 [root@localhost ~]# ansible server -m user -a 'name=test01 uid=8888 home=/home/test01 group=root' ... [root@localhost ~]# ansible server -a 'getent passwd test01' 10.91.156.205 | CHANGED | rc=0 >> test01:x:8888:0::/home/test01:/bin/bash # 删除 test01 用户并删除家目录 [root@localhost ~]# ansible server -m user -a 'name=test01 state=absent remove=yes' Group模块 功能 管理用户组 示例 #创建组 ansible websrvs -m group -a 'name=nginx gid=88 system=yes' #删除组 ansible websrvs -m group -a 'name=nginx state=absent' Lineinfile模块 功能 相当于sed，可以修改文件内容。 ansible在使用sed进行替换时，经常会遇到需要转义的问题，而且ansible在遇到特殊符号进行替换时，存在问题，无法正常进行替换 。其实在ansible自身提供了两个模块：lineinfile模块和replace模块，可以方便的进行替换 示例 ansible all -m lineinfile -a \"path=/etc/selinux/config regexp='^SELINUX=' line='SELINUX=enforcing'\" ansible all -m lineinfile -a 'dest=/etc/fstab state=absent regexp=\"^#\"' Replace模块 功能 该模块有点类似于sed命令，主要也是基于正则进行匹配和替换 示例 ansible all -m replace -a \"path=/etc/fstab regexp='^(UUID.*)' replace='#\\1'\" ansible all -m replace -a \"path=/etc/fstab regexp='^#(.*)' replace='\\1'\" Setup模块 功能 setup 模块来收集主机的系统信息，这些 facts 信息可以直接以变量的形式使用，但是如果主机较多，会影响执行速度，可以使用 gather_facts: no 来禁止 Ansible 收集 facts 信息 常见参数 参数 说明 filter 按照key过滤输出结果，支持通配符 gather_timeout 设置收集数据的超时时间 示例 [root@localhost ~]# ansible server -m setup -a 'filter=ansible_virtualization_type' 10.91.156.205 | SUCCESS => { \"ansible_facts\": { \"ansible_virtualization_type\": \"kvm\", \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false } 可不加filter获取全部信息后，找到自己所需的字段，再通过filter方式获取指定字段 "},"ansible/Playbook.html":{"url":"ansible/Playbook.html","title":"Playbook","keywords":"","body":"参考 bilibili马哥视频 运维派教程 介绍 在Playbook中，使用task来定义一个子任务，并在任务中指定需要使用的模块，以及触发条件等信息。最终一个Playbook的Yml文件中可由多个task组成，按照任务顺序对指定主机进行自动化运维 YAML语言 教程 https://www.runoob.com/w3cnote/yaml-intro.html 核心元素 Hosts 执行的远程主机列表 remote_user：指定执行任务时在远程主机上所用的用户 Tasks 任务集 Variables 内置变量或自定义变量在playbook中调用 Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件 Handlers 和 notify 结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行 tags 标签 指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断 注：hosts用于指定要执行指定任务的主机，须事先定义在主机清单中 playbook命令 格式 ansible-playbook ... [options] 常见选项 -C --check #只检测可能会发生的改变，但不真正执行操作 --list-hosts #列出运行任务的主机 --list-tags #列出tag --list-tasks #列出task --limit 主机列表 #只针对主机列表中的主机执行 -v -vv -vvv #显示过程 playbook初步 开启远程主机mysql的远程访问权限 [root@localhost playbook]# cat config-mysql.yml --- - hosts: csmp gather_facts: no tasks: - name: Open mysql remote access permissions replace: path=/etc/my.cnf.d/server.cnf regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true - name: restart mysql service: name=mysql state=restarted 执行 [root@localhost playbook]# ansible-playbook config-mysql.yml -vv handlers和notify 作用 只有当关注的资源发生变化时，才会采取一定的操作。在notify中列出的操作成为handler 示例 改写上面的例子，只有当配置文件修改的时候才重启mysql服务 --- - hosts: csmp gather_facts: no tasks: - name: Open mysql remote access permissions replace: path=/etc/my.cnf.d/server.cnf regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted tags组件 作用 在playbook中，可以利用tags组件，为特定task指定标签，当在执行playbook时，可以只执行特定tags的tasks，而非整个playbook文件 示例 --- - hosts: csmp gather_facts: no tasks: - name: Open mysql remote access permissions replace: path=/etc/my.cnf.d/server.cnf regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true tags: replace - name: restart mysql service: name=mysql state=restarted tags: effective 此时就可只通过tags执行其中某一个task [root@localhost playbook]# ansible-playbook config-mysql.yml --list-tags playbook: config-mysql.yml play #1 (csmp): csmp TAGS: [] TASK TAGS: [effective, replace] # -t TAGS, --tags TAGS only run plays and tasks tagged with these values [root@localhost playbook]# ansible-playbook -t effective config-mysql.yml ansible中使用变量 定义 仅能由字母、数字和下划线组成，且只能以字母开头 variable=value 调用 通过 调用变量，且变量名前后建议加空格，有时用“”才生效 使用setup模块中变量 要求在playbook中使用，不要用ansible命令调用 --- #var.yml - hosts: all remote_user: root gather_facts: yes tasks: - name: create log file file: name=/data/.log state=touch owner=wang mode=600 ansible-playbook var.yml 在playbook命令行中定义变量 通过-e参数使用 -e EXTRA_VARS, --extra-vars EXTRA_VARS set additional variables as key=value or YAML/JSON, if filename prepend with @ 示例： --- - hosts: \"\" gather_facts: no tasks: - name: Open mysql remote access permissions replace: path=/etc/my.cnf.d/server.cnf regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted 在执行时通过-e指定server变量。 [root@localhost playbook]# ansible-playbook config-mysql.yml -e server=10.47.119.156 在playbook文件中定义变量 vars中定义变量，在后续直接使用 --- - hosts: \"\" gather_facts: no vars: - path: /etc/my.cnf.d/server.cnf tasks: - name: Open mysql remote access permissions replace: path= regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted 使用变量文件 可以在一个独立的playbook文件中定义变量，在另一个playbook文件中引用变量文件中的变量，比playbook中定义的变量优先级高 # 定义变量文件 [root@localhost playbook]# cat config-mysql-var.yml --- server_conf_path: /etc/my.cnf.d/server.cnf # playbook文件中引入使用 [root@localhost playbook]# cat config-mysql.yml --- - hosts: \"\" gather_facts: no vars_files: - config-mysql-var.yml tasks: - name: Open mysql remote access permissions replace: path= regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted 主机清单文件中定义变量 主机（普通）变量 在inventory主机清单文件中为指定得主机定义变量，以便在playbook中使用 [root@localhost playbook]# cat /etc/ansible/hosts [server] 10.47.119.156 server_conf_path=/etc/my.cnf.d/server.cnf 10.47.119.157 server_conf_path=/etc/my.cnf.d/server1.cnf 组（公共）变量 在inventory 主机清单文件中赋予给指定组内所有主机上的在playbook中可用的变量，如果和主机变是同名，优先级低于主机变量 [root@localhost playbook]# cat /etc/ansible/hosts [server] 10.47.119.156 10.47.119.157 [server:vars] server_conf_path=/etc/my.cnf.d/server.cnf 使用时直接使用变量即可 --- - hosts: \"\" gather_facts: no tasks: - name: Open mysql remote access permissions replace: path= regexp='^(bind-address=127.0.0.1)' replace='#\\1' backup=true notify: restart mysql handlers: - name: restart mysql service: name=mysql state=restarted template模板 jinja2语言 官网：https://jinja.palletsprojects.com/en/2.11.x/ template 功能 可以根据和参考模块文件，动态生成相类似的配置文件 要求 template文件必须存放于templates目录下，且命名为 .j2 结尾 yaml/yml文件需和templates目录平级，目录结构如下示例： . ├── config.yml └── templates └── nginx.conf.j2 示例 # tree . ├── config-nginx.yml └── templates └── nginx.conf.j2 设置nginx进程数与ansible_processor_vcpus+1相等 # cat templates/nginx.conf.j2 ... worker_processes NaN; ... playbook内容 # cat config-nginx.yml --- - hosts: vm tasks: - name: template config to remote hosts template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: restart nginx handlers: - name: restart nginx service: name=nginx state=restarted 使用setup模块发现ansible_processor_vcpus值为4，所以模板文件中对应nginx子进程数应为5 # ansible vm -m setup -a 'filter=ansible_processor_vcpus' 10.91.156.205 | SUCCESS => { \"ansible_facts\": { \"ansible_processor_vcpus\": 4, \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false } 统计nginx子进程数目 # ansible vm -m 'shell' -a \"ps aux | grep 'nginx: worker process' \" 10.91.156.205 | CHANGED | rc=0 >> nginx 24585 0.0 0.0 105956 3444 ? S 15:05 0:00 nginx: worker process nginx 24586 0.0 0.0 105956 3444 ? S 15:05 0:00 nginx: worker process nginx 24587 0.0 0.0 105956 3444 ? S 15:05 0:00 nginx: worker process nginx 24588 0.0 0.0 105956 3444 ? S 15:05 0:00 nginx: worker process nginx 24589 0.0 0.0 105956 3448 ? S 15:05 0:00 nginx: worker process ... 流程控制 template中可使用流程控制 for 循环和 if 条件判断，实现动态生成文件功能 for循环 示例 j2文件： ... ... playbook文件中src指定j2文件，拷贝到远程主机后记得要修改名称 --- - hosts: vm gather_facts: no vars: listen_ports: - 8888 - 8889 tasks: - name: template config to remote hosts template: src=nginx-server.conf.j2 dest=/etc/nginx/nginx.conf backup=true notify: restart nginx handlers: - name: restart nginx service: name=nginx state=restarted 验证发现服务器nginx.cnf中多出了8888，8889两个server ... server { listen 8888; root /usr/share/nginx/html; location / { } } server { listen 8889; root /usr/share/nginx/html; location / { } } .... 若vars中变量是字典形式，形如 vars: nginx_vhosts: - listen: 8080 server_name: \"web1.magedu.com\" root: \"/var/www/nginx/web1/\" - listen: 8081 server_name: \"web2.magedu.com\" root: \"/var/www/nginx/web2/\" jinja2就需要使用如下方式调用 if 判断 在模板文件中可通过条件判断，来决定相关配置得生成信息。例如 # cat if-config.yml --- - hosts: vm gather_facts: no vars: nginx_vhosts: - listen: 80 server_name: \"server1\" root: \"/var/www/nginx/web1\" - listen: 8080 root: \"var/www/nginx/web2\" tasks: - name: template config if exp template: src=if-config.cnf.j2 dest=/root/if-config.cnf 模板文件 最终生成结果 #结果 server { listen 80 server_name server1 root /var/www/nginx/web1 } server { listen 8080 root var/www/nginx/web2 } playbook使用when when语句，可实现条件测试。如果需要根据变量，facts或此前任务得执行结果来作为某task执行与否的前提时要用到条件测试。通过在task后添加when子句即可使用条件测试。 示例 如果ansible_os_family值为RedHat则创建/root/redhat目录，否则创建/root/others目录 --- - hosts: vm tasks: - name: mkdir redhat dir shell: mkdir /root/redhat when: ansible_os_family == \"RedHat\" - name: mkdir other dir shell: mkdir /root/otherOs when: ansible_os_family != \"RedHat\" 迭代with_items 作用 当有需要重复性执行的任务时，可以使用迭代机制。对迭代项的引用，固定变量名为\"item\"。要在task中使用with_items给定要迭代的元素列表 列表元素格式 字符串 --- - hosts: vm gather_facts: no tasks: - name: install tools yum: name= state=installed with_items: - lrzsz - wget 等同于 --- - hosts: vm gather_facts: no tasks: - name: install lrzsz yum: name=lrzsz state=installed - name: install wget yum: name=wget state=installed 字典 --- - hosts: vm gather_facts: no tasks: - name: copy config file copy: src= dest= with_items: - { src: /root/src1.cnf, dest: /root/dest1.txt } - { src: /root/src2.cnf, dest: /root/dest2.txt } "},"ansible/roles角色.html":{"url":"ansible/roles角色.html","title":"Roles","keywords":"","body":"参考 bilibili马哥视频 运维派教程 介绍 roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制 目录组织 ├──playbook.yml ├── roles │ ├── project │ ├── default │ ├── files │ ├── handlers │ ├── meta │ ├── tasks │ ├── templates │ └── vars 使用roles的playbook需要与roles文件目录平级，roles中目录作用如下 files/ ：存放由copy或script模块等调用的文件 templates/：template模块查找所需要模板文件的目录 tasks/：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含 handlers/：至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含 vars/：定义变量，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含 meta/：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，其它文件需在此文件中通过include进行包含 default/：设定默认变量时使用此目录中的main.yml文件，比vars的优先级低 示例1：实现httpd角色 目的 当引入httpd角色时，可以达到以下几个目的 为远程主机安装httpd并设置为开机自启动 将首页文件以及httpd配置文件拷贝到对应位置 重启服务生效 目录结构 . ├── role-install-httpd.yml ├── roles │ └── httpd │ ├── files │ │ ├── httpd.conf │ │ └── index.html │ ├── handlers │ │ └── main.yml │ └── tasks │ ├── config.yml │ ├── enable.yml │ ├── index.yml │ ├── install.yml │ └── main.yml playbbok内容 # cat role-install-httpd.yml - hosts: vm gather_facts: no roles: - httpd tasks内容 # cat roles/httpd/tasks/install.yml - name: install httpd package yum: name=httpd # cat roles/httpd/tasks/config.yml - name: config file copy: src=httpd.conf dest=/etc/httpd/conf/ backup=yes notify: restart # cat roles/httpd/tasks/index.yml - name: copy index copy: src=index.html dest=/var/www/html/ # cat roles/httpd/tasks/enable.yml - name: start service service: name=httpd state=started enabled=yes handlers内容 # cat roles/httpd/handlers/main.yml - name: restart service: name=httpd state=restarted 示例2：实现nginx角色 目的 在上一个例子的基础上增加templates以及vars。 配置文件由模板文件自动生成 nginx由指定的远程主机用户suhw启动 目录结构 ├── role-install-nginx.yml ├── roles │ └── nginx │ ├── handlers │ │ └── main.yml │ ├── tasks │ │ ├── config.yml │ │ ├── enable.yml │ │ ├── index.yml │ │ ├── install.yml │ │ └── main.yml │ ├── templates │ │ └── nginx.conf.j2 │ └── vars │ └── main.yml playbook内容 # cat role-install-nginx.yml - hosts: vm roles: - nginx tasks内容 # cat tasks/main.yml - include: install.yml - include: config.yml - include: index.yml - include: enable.yml # cat tasks/install.yml - name: install yum: name=nginx # cat tasks/config.yml - name: config nginx template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: restart # cat tasks/index.yml - name: copy index copy: src=roles/httpd/files/index.html dest=/usr/share/nginx/html # cat tasks/enable.yml - name: enable and start service service: name=nginx state=started enabled=yes templates内容 ... user ; worker_processes NaN; ... handlers内容 # cat handlers/main.yml - name: restart service: name=nginx state=restarted vars内容 cat vars/main.yml user: suhw "}}